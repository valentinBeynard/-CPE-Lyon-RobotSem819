C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COMMANDS
OBJECT MODULE PLACED IN .\Objects\commands.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\commands.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\commands.lst) TABS(2) OBJECT(.\Objects\commands.obj)

line level    source

   1          #include "commands.h"
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          byte default_process(CMD_PACKET* cmd_packet)
   7          {
   8   1        //printf("Non-implemented command !!");
   9   1        cmd_packet->commands->Etat_Epreuve = (enum Epreuve)1;
  10   1        
  11   1        return 1;
  12   1      }
  13          
  14          /*
  15            Commande de démarage de l'épreuve : D [Numéro Epreuve]
  16            Si aucun paramètre rentré, alors on démarre à l'épreuve 1
  17          */
  18          byte epreuve_cmd(CMD_PACKET* cmd_packet)
  19          {
  20   1        int epreuve_index = 1;
  21   1      
  22   1        // Trop d'argument
  23   1        if(cmd_packet->cmd_size > 1)
  24   1        {
  25   2          return 0;
  26   2        }
  27   1      
  28   1        // Si le paramètre correspondant au numéro d'épreuve est présent
  29   1        if(cmd_packet->cmd_size == 1)
  30   1        {
  31   2          // Si valeur non numérique
  32   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%u", &epreuve_index) != 1)
  33   2          {
  34   3            return 0;
  35   3          }
  36   2      
  37   2          // Si pas dans l'intervalle de valeur acceptées
  38   2          if(epreuve_index < 1 || epreuve_index > 9)
  39   2          {
  40   3            return 0;
  41   3          }
  42   2          
  43   2          cmd_packet->commands->Etat_Epreuve = (enum Epreuve)epreuve_index;
  44   2        }
  45   1        else
  46   1        {
  47   2          cmd_packet->commands->Etat_Epreuve = epreuve1;
  48   2        }
  49   1        return 1;
  50   1      }
  51          
  52          byte epreuve_stop(CMD_PACKET* cmd_packet)
  53          {
  54   1        //printf("Non-implemented command !!");
C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 2   

  55   1        cmd_packet->commands->Etat_Epreuve = Epreuve_non;
  56   1        
  57   1        return 1;
  58   1      }
  59          
  60          
  61          byte safety_break_cmd(CMD_PACKET* cmd_packet)
  62          {
  63   1        // Trop d'argument
  64   1        if(cmd_packet->cmd_size > 0)
  65   1        {
  66   2          return 0;
  67   2        }
  68   1      
  69   1        cmd_packet->commands->Etat_Epreuve = Stop_Urgence;
  70   1        
  71   1        return 1;
  72   1      }
  73          
  74          byte set_default_speed_cmd(CMD_PACKET* cmd_packet)
  75          {
  76   1        int motor_speed = 20;
  77   1        
  78   1        // Seu la commande TV valeur est acceptée
  79   1        if(cmd_packet->cmd_size != 1)
  80   1        {
  81   2          return 0;
  82   2        }
  83   1        
  84   1        // Si valeur non numérique
  85   1        if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) != 1)
  86   1        {
  87   2          return 0;
  88   2        }
  89   1        
  90   1        // Si pas dans l'intervalle de valeur acceptées
  91   1        if(motor_speed < 0 || motor_speed > 100)
  92   1        {
  93   2          return 0;
  94   2        }
  95   1        
  96   1        cmd_packet->commands->Vitesse = motor_speed;
  97   1      
  98   1        return 1;
  99   1      }
 100          
 101          byte move_forward_cmd(CMD_PACKET* cmd_packet)
 102          {
 103   1        int motor_speed = 20;
 104   1        
 105   1        if(cmd_packet->cmd_size > 1)
 106   1        {
 107   2          return 0;
 108   2        }
 109   1          
 110   1        cmd_packet->commands->Etat_Mouvement = Avancer;
 111   1      
 112   1        if(cmd_packet->cmd_size == 1)
 113   1        {
 114   2          // Si valeur non numérique
 115   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 116   2          {
C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 3   

 117   3            return 0;
 118   3          }
 119   2          
 120   2          // Si pas dans l'intervalle de valeur acceptées
 121   2          if(motor_speed < 0 || motor_speed > 100)
 122   2          {
 123   3            return 0;
 124   3          }
 125   2          
 126   2          cmd_packet->commands->Vitesse = motor_speed;
 127   2        }else{
 128   2          if(cmd_packet->commands->Vitesse == 0)
 129   2          {
 130   3            cmd_packet->commands->Vitesse = motor_speed;
 131   3          }
 132   2        }
 133   1        return 1;
 134   1      }
 135          
 136          byte move_backward_cmd(CMD_PACKET* cmd_packet)
 137          {
 138   1        int motor_speed = 20;
 139   1        
 140   1        if(cmd_packet->cmd_size > 1)
 141   1        {
 142   2          return 0;
 143   2        }
 144   1          
 145   1        cmd_packet->commands->Etat_Mouvement = Reculer;
 146   1      
 147   1        if(cmd_packet->cmd_size == 1)
 148   1        {
 149   2          // Si valeur non numérique
 150   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 151   2          {
 152   3            return 0;
 153   3          }
 154   2          
 155   2          // Si pas dans l'intervalle de valeur acceptées
 156   2          if(motor_speed < 0 || motor_speed > 100)
 157   2          {
 158   3            return 0;
 159   3          }
 160   2          
 161   2          cmd_packet->commands->Vitesse = motor_speed;
 162   2        }else{
 163   2          if(cmd_packet->commands->Vitesse == 0)
 164   2          {
 165   3            cmd_packet->commands->Vitesse = motor_speed;
 166   3          }
 167   2        }
 168   1        return 1;
 169   1      }
 170          
 171          byte move_stop_cmd(CMD_PACKET* cmd_packet)
 172          { 
 173   1        if(cmd_packet->cmd_size != 0)
 174   1        {
 175   2          return 0;
 176   2        }
 177   1        cmd_packet->commands->Etat_Mouvement = Stopper;
 178   1        return 1;
C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 4   

 179   1      }
 180          
 181          byte rigth_rotation_cmd(CMD_PACKET* cmd_packet)
 182          {
 183   1        if(cmd_packet->cmd_size != 0)
 184   1        {
 185   2          return 0;
 186   2        }
 187   1        
 188   1        cmd_packet->commands->Etat_Mouvement = Rot_90D;
 189   1        return 1;
 190   1      }
 191          
 192          byte left_rotation_cmd(CMD_PACKET* cmd_packet)
 193          {
 194   1        if(cmd_packet->cmd_size != 0)
 195   1        {
 196   2          return 0;
 197   2        }
 198   1        
 199   1        cmd_packet->commands->Etat_Mouvement = Rot_90G;
 200   1        return 1;
 201   1      }
 202          
 203          byte complete_rotation_cmd(CMD_PACKET* cmd_packet)
 204          {
 205   1        if(cmd_packet->cmd_size > 1)
 206   1        {
 207   2          return 0;
 208   2        }
 209   1      
 210   1        if(cmd_packet->cmd_size == 1)
 211   1        {
 212   2          
 213   2          if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "D") == 0 
 214   2            || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "G") == 0)
 215   2          {
 216   3            switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 217   3            {
 218   4              case 'D':
 219   4                cmd_packet->commands->Etat_Mouvement = Rot_180D;
 220   4                break;
 221   4              default :
 222   4                cmd_packet->commands->Etat_Mouvement = Rot_180G;
 223   4                break;
 224   4            }
 225   3          }else{
 226   3            return 0;
 227   3          }
 228   2      
 229   2        }else{
 230   2          cmd_packet->commands->Etat_Mouvement = Rot_180D;
 231   2        }
 232   1        return 1;
 233   1      }
 234          
 235          byte angle_rotation_cmd(CMD_PACKET* cmd_packet)
 236          {
 237   1        unsigned int angle = 0;
 238   1        
 239   1        if(cmd_packet->cmd_size != 2)
 240   1        {
C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 5   

 241   2          return 0;
 242   2        }
 243   1        
 244   1        if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "D") == 0 
 245   1            || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "G") == 0)
 246   1        {
 247   2          switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 248   2          {
 249   3            case 'D':
 250   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 251   3              break;
 252   3            default :
 253   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 254   3              break;
 255   3          }
 256   2          
 257   2          if(sscanf((cmd_packet->commands_data + (2 * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 258   2          {
 259   3            return 0;
 260   3          }
 261   2          
 262   2          cmd_packet->commands->Angle = (int)(angle);
 263   2        }else{
 264   2          return 0;
 265   2        }
 266   1        return 1;
 267   1      }
 268          
 269          /*
 270            Move to (X,Y,alpha) coordinate
 271          
 272            Ex : "G X:10 Y:15 A:45"
 273          
 274          */
 275          byte move_to_cmd(CMD_PACKET* cmd_packet)
 276          {
 277   1        byte i = 0, j = 0;
 278   1        char params[3][5] = {"X", "Y", "A"};
 279   1        int angle = 0, x = 0, y = 0;
 280   1        byte param_find = 0;
 281   1        char * str = 0;
 282   1        
 283   1        
 284   1        // Not enougth args
 285   1        if(cmd_packet->cmd_size != 6)
 286   1        {
 287   2          return 0;
 288   2        }
 289   1        
 290   1        /*
 291   1          This Code section is working just in level 1 compiler optimization...
 292   1          sscanf seems to involve data overlaying. Thus, we can test commands 
 293   1          data since they are modify during the process ...
 294   1        */
 295   1        
 296   1        // Analyse each param:value couple
 297   1        for(i = 0 ; i < 3 ; ++i)
 298   1        {
 299   2          str = (cmd_packet->commands_data + ( ((2*i) + 1) * ARGS_BUFFER_SIZE));
 300   2          
 301   2          // For one couple, identify the param
 302   2          for(j = 0 ; j < 3 ; j++)
C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 6   

 303   2          {
 304   3            if( strcmp(str, params[j]) == 0 )
 305   3            {
 306   4              switch(j)
 307   4              {
 308   5                case 0:
 309   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &x) == 0)
 310   5                  {
 311   6                    return 0;
 312   6                  }         
 313   5                  break;
 314   5                
 315   5                case 1:
 316   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &y) == 0)
 317   5                  {
 318   6                    return 0;
 319   6                  }   
 320   5                  break;
 321   5                
 322   5                case 2:
 323   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 324   5                  {
 325   6                    return 0;
 326   6                  } 
 327   5                  break;
 328   5                
 329   5              }
 330   4              param_find = 1;
 331   4              break;
 332   4            }
 333   3          }
 334   2          
 335   2          if(param_find == 0)
 336   2          {
 337   3            return 0;
 338   3          }else{
 339   3            param_find = 0;
 340   3          }
 341   2          
 342   2        }
 343   1        
 344   1        cmd_packet->commands->Angle = angle;
 345   1        cmd_packet->commands->Coord_X = (byte)x;
 346   1        cmd_packet->commands->Coord_Y = (byte)y;
 347   1        cmd_packet->commands->Etat_Mouvement = Depl_Coord;
 348   1        return 1;
 349   1      }
 350          
 351          byte detecte_obstacle(CMD_PACKET* cmd_packet)
 352          {
 353   1        if(cmd_packet->cmd_size != 0)
 354   1        {
 355   2          return 0;
 356   2        }
 357   1        
 358   1        cmd_packet->commands->Etat_DCT_Obst = oui_180;
 359   1        return 1;
 360   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3103    ----
C51 COMPILER V9.55   COMMANDS                                                              03/31/2019 22:32:48 PAGE 7   

   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----      79
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
