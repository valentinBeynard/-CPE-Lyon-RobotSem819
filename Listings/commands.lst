C51 COMPILER V9.55   COMMANDS                                                              03/11/2019 23:13:37 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COMMANDS
OBJECT MODULE PLACED IN .\Objects\commands.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\commands.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\commands.lst) TABS(2) OBJECT(.\Objects\commands.obj)

line level    source

   1          #include "commands.h"
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          byte default_process(CMD_PACKET* cmd_packet)
   7          {
   8   1        //printf("Non-implemented command !!");
   9   1      }
*** WARNING C173 IN LINE 9 OF src\commands.c: missing return-expression
*** WARNING C280 IN LINE 6 OF src\commands.c: 'cmd_packet': unreferenced local variable
  10          
  11          /*
  12            Commande de démarage de l'épreuve : D [Numéro Epreuve]
  13            Si aucun paramètre rentré, alors on démarre à l'épreuve 1
  14          */
  15          byte epreuve_cmd(CMD_PACKET* cmd_packet)
  16          {
  17   1        int epreuve_index = 1;
  18   1        int c = 0;
  19   1        char* str;
  20   1        char** str_2;
  21   1        // Trop d'argument
  22   1        if(cmd_packet->cmd_size > 1)
  23   1        {
  24   2          return 0;
  25   2        }
  26   1      
  27   1        // Si le paramètre correspondant au numéro d'épreuve est présent
  28   1        if(cmd_packet->cmd_size == 1)
  29   1        {
  30   2          // Si valeur non numérique
  31   2          str = (cmd_packet->commands_data + 1);
*** WARNING C182 IN LINE 31 OF src\commands.c: pointer to different objects
  32   2          str_2 = (cmd_packet->commands_data + 1);
  33   2          c = sscanf(str, "%d", &epreuve_index);
  34   2          if(c != 1)
  35   2          {
  36   3            return 0;
  37   3          }
  38   2      
  39   2          // Si pas dans l'intervalle de valeur acceptées
  40   2          if(epreuve_index < 1 || epreuve_index > 9)
  41   2          {
  42   3            return 0;
  43   3          }
  44   2          
  45   2          cmd_packet->commands->Etat_Epreuve = (enum Epreuve)epreuve_index;
  46   2        }
  47   1        else
  48   1        {
  49   2          cmd_packet->commands->Etat_Epreuve = epreuve1;
  50   2        }
  51   1        return 1;
C51 COMPILER V9.55   COMMANDS                                                              03/11/2019 23:13:37 PAGE 2   

  52   1      }
  53          
  54          
  55          byte safety_break_cmd(CMD_PACKET* cmd_packet)
  56          {
  57   1        // Trop d'argument
  58   1        if(cmd_packet->cmd_size > 0)
  59   1        {
  60   2          return 0;
  61   2        }
  62   1      
  63   1        cmd_packet->commands->Etat_Epreuve = Stop_Urgence;
  64   1        
  65   1        return 1;
  66   1      }
  67          
  68          byte set_default_speed_cmd(CMD_PACKET* cmd_packet)
  69          {
  70   1        byte motor_speed = 20;
  71   1        
  72   1        // Seu la commande TV valeur est acceptée
  73   1        if(cmd_packet->cmd_size != 1)
  74   1        {
  75   2          return 0;
  76   2        }
  77   1        
  78   1        // Si valeur non numérique
  79   1        if(sscanf(*(cmd_packet->commands_data + 1), "%d", motor_speed) == 0)
  80   1        {
  81   2          return 0;
  82   2        }
  83   1        
  84   1        // Si pas dans l'intervalle de valeur acceptées
  85   1        if(motor_speed < 0 || motor_speed > 100)
  86   1        {
  87   2          return 0;
  88   2        }
  89   1        
  90   1        cmd_packet->commands->Vitesse = motor_speed;
  91   1      
  92   1        return 1;
  93   1      }
  94          
  95          byte move_forward_cmd(CMD_PACKET* cmd_packet)
  96          {
  97   1        byte motor_speed = 20;
  98   1        
  99   1        if(cmd_packet->cmd_size > 1)
 100   1        {
 101   2          return 0;
 102   2        }
 103   1          
 104   1        cmd_packet->commands->Etat_Mouvement = Avancer;
 105   1      
 106   1        if(cmd_packet->cmd_size == 1)
 107   1        {
 108   2          // Si valeur non numérique
 109   2          if(sscanf(*(cmd_packet->commands_data + 1), "%d", motor_speed) == 0)
 110   2          {
 111   3            return 0;
 112   3          }
 113   2          
C51 COMPILER V9.55   COMMANDS                                                              03/11/2019 23:13:37 PAGE 3   

 114   2          // Si pas dans l'intervalle de valeur acceptées
 115   2          if(motor_speed < 0 || motor_speed > 100)
 116   2          {
 117   3            return 0;
 118   3          }
 119   2          
 120   2          cmd_packet->commands->Vitesse = motor_speed;
 121   2        }else{
 122   2          if(cmd_packet->commands->Vitesse == 0)
 123   2          {
 124   3            cmd_packet->commands->Vitesse = motor_speed;
 125   3          }
 126   2        }
 127   1        return 1;
 128   1      }
 129          
 130          byte move_backward_cmd(CMD_PACKET* cmd_packet)
 131          {
 132   1        byte motor_speed = 20;
 133   1        
 134   1        if(cmd_packet->cmd_size > 1)
 135   1        {
 136   2          return 0;
 137   2        }
 138   1          
 139   1        cmd_packet->commands->Etat_Mouvement = Reculer;
 140   1      
 141   1        if(cmd_packet->cmd_size == 1)
 142   1        {
 143   2          // Si valeur non numérique
 144   2          if(sscanf(*(cmd_packet->commands_data + 1), "%d", motor_speed) == 0)
 145   2          {
 146   3            return 0;
 147   3          }
 148   2          
 149   2          // Si pas dans l'intervalle de valeur acceptées
 150   2          if(motor_speed < 0 || motor_speed > 100)
 151   2          {
 152   3            return 0;
 153   3          }
 154   2          
 155   2          cmd_packet->commands->Vitesse = motor_speed;
 156   2        }else{
 157   2          if(cmd_packet->commands->Vitesse == 0)
 158   2          {
 159   3            cmd_packet->commands->Vitesse = motor_speed;
 160   3          }
 161   2        }
 162   1        return 1;
 163   1      }
 164          
 165          byte move_stop_cmd(CMD_PACKET* cmd_packet)
 166          { 
 167   1        if(cmd_packet->cmd_size != 0)
 168   1        {
 169   2          return 0;
 170   2        }
 171   1        cmd_packet->commands->Vitesse = Stopper;
 172   1        return 1;
 173   1      }
 174          
 175          byte rigth_rotation_cmd(CMD_PACKET* cmd_packet)
C51 COMPILER V9.55   COMMANDS                                                              03/11/2019 23:13:37 PAGE 4   

 176          {
 177   1        if(cmd_packet->cmd_size != 0)
 178   1        {
 179   2          return 0;
 180   2        }
 181   1        
 182   1        cmd_packet->commands->Etat_Mouvement = Rot_90D;
 183   1        return 1;
 184   1      }
 185          
 186          byte left_rotation_cmd(CMD_PACKET* cmd_packet)
 187          {
 188   1        if(cmd_packet->cmd_size != 0)
 189   1        {
 190   2          return 0;
 191   2        }
 192   1        
 193   1        cmd_packet->commands->Etat_Mouvement = Rot_90G;
 194   1        return 1;
 195   1      }
 196          
 197          byte complete_rotation_cmd(CMD_PACKET* cmd_packet)
 198          {
 199   1        if(cmd_packet->cmd_size > 1)
 200   1        {
 201   2          return 0;
 202   2        }
 203   1      
 204   1        if(cmd_packet->cmd_size == 1)
 205   1        {
 206   2          
 207   2          if(strcmp(*(cmd_packet->commands_data + 1), "D") == 0 
 208   2            || strcmp(*(cmd_packet->commands_data + 1), "G") == 0)
 209   2          {
 210   3            switch( *(*(cmd_packet->commands_data + 1)) )
 211   3            {
 212   4              case 'D':
 213   4                cmd_packet->commands->Etat_Mouvement = Rot_180D;
 214   4                break;
 215   4              default :
 216   4                cmd_packet->commands->Etat_Mouvement = Rot_180G;
 217   4                break;
 218   4            }
 219   3          }else{
 220   3            return 0;
 221   3          }
 222   2      
 223   2        }else{
 224   2          cmd_packet->commands->Etat_Mouvement = Rot_180D;
 225   2        }
 226   1        return 1;
 227   1      }
 228          
 229          byte angle_rotation_cmd(CMD_PACKET* cmd_packet)
 230          {
 231   1        unsigned int angle = 90;
 232   1        
 233   1        if(cmd_packet->cmd_size != 2)
 234   1        {
 235   2          return 0;
 236   2        }
 237   1        
C51 COMPILER V9.55   COMMANDS                                                              03/11/2019 23:13:37 PAGE 5   

 238   1        if(strcmp(*(cmd_packet->commands_data + 1), "D") == 0 
 239   1            || strcmp(*(cmd_packet->commands_data + 1), "G") == 0)
 240   1        {
 241   2          switch( *(*(cmd_packet->commands_data + 1)) )
 242   2          {
 243   3            case 'D':
 244   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 245   3              break;
 246   3            default :
 247   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 248   3              break;
 249   3          }
 250   2          
 251   2          if(sscanf(*(cmd_packet->commands_data + 2), "%d", angle) == 0)
 252   2          {
 253   3            return 0;
 254   3          }
 255   2          
 256   2          cmd_packet->commands->Angle = (int)(100 * angle);
 257   2        }else{
 258   2          return 0;
 259   2        }
 260   1        return 1;
 261   1      }
*** WARNING C290 IN LINE 9 OF src\commands.c: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1400    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =   ----      34
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
