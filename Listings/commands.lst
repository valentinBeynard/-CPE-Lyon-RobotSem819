C51 COMPILER V9.55   COMMANDS                                                              03/17/2019 13:26:14 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COMMANDS
OBJECT MODULE PLACED IN .\Objects\commands.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\commands.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\commands.lst) TABS(2) OBJECT(.\Objects\commands.obj)

line level    source

   1          #include "commands.h"
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          byte default_process(CMD_PACKET* cmd_packet)
   7          {
   8   1        //printf("Non-implemented command !!");
   9   1        cmd_packet->commands->Etat_Epreuve = (enum Epreuve)1;
  10   1        
  11   1        return 1;
  12   1      }
  13          
  14          /*
  15            Commande de démarage de l'épreuve : D [Numéro Epreuve]
  16            Si aucun paramètre rentré, alors on démarre à l'épreuve 1
  17          */
  18          byte epreuve_cmd(CMD_PACKET* cmd_packet)
  19          {
  20   1        int epreuve_index = 1;
  21   1      
  22   1        // Trop d'argument
  23   1        if(cmd_packet->cmd_size > 1)
  24   1        {
  25   2          return 0;
  26   2        }
  27   1      
  28   1        // Si le paramètre correspondant au numéro d'épreuve est présent
  29   1        if(cmd_packet->cmd_size == 1)
  30   1        {
  31   2          // Si valeur non numérique
  32   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%u", &epreuve_index) != 1)
  33   2          {
  34   3            return 0;
  35   3          }
  36   2      
  37   2          // Si pas dans l'intervalle de valeur acceptées
  38   2          if(epreuve_index < 1 || epreuve_index > 9)
  39   2          {
  40   3            return 0;
  41   3          }
  42   2          
  43   2          cmd_packet->commands->Etat_Epreuve = (enum Epreuve)epreuve_index;
  44   2        }
  45   1        else
  46   1        {
  47   2          cmd_packet->commands->Etat_Epreuve = epreuve1;
  48   2        }
  49   1        return 1;
  50   1      }
  51          
  52          
  53          byte safety_break_cmd(CMD_PACKET* cmd_packet)
  54          {
C51 COMPILER V9.55   COMMANDS                                                              03/17/2019 13:26:14 PAGE 2   

  55   1        // Trop d'argument
  56   1        if(cmd_packet->cmd_size > 0)
  57   1        {
  58   2          return 0;
  59   2        }
  60   1      
  61   1        cmd_packet->commands->Etat_Epreuve = Stop_Urgence;
  62   1        
  63   1        return 1;
  64   1      }
  65          
  66          byte set_default_speed_cmd(CMD_PACKET* cmd_packet)
  67          {
  68   1        int motor_speed = 20;
  69   1        
  70   1        // Seu la commande TV valeur est acceptée
  71   1        if(cmd_packet->cmd_size != 1)
  72   1        {
  73   2          return 0;
  74   2        }
  75   1        
  76   1        // Si valeur non numérique
  77   1        if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) != 1)
  78   1        {
  79   2          return 0;
  80   2        }
  81   1        
  82   1        // Si pas dans l'intervalle de valeur acceptées
  83   1        if(motor_speed < 0 || motor_speed > 100)
  84   1        {
  85   2          return 0;
  86   2        }
  87   1        
  88   1        cmd_packet->commands->Vitesse = motor_speed;
  89   1      
  90   1        return 1;
  91   1      }
  92          
  93          byte move_forward_cmd(CMD_PACKET* cmd_packet)
  94          {
  95   1        int motor_speed = 20;
  96   1        
  97   1        if(cmd_packet->cmd_size > 1)
  98   1        {
  99   2          return 0;
 100   2        }
 101   1          
 102   1        cmd_packet->commands->Etat_Mouvement = Avancer;
 103   1      
 104   1        if(cmd_packet->cmd_size == 1)
 105   1        {
 106   2          // Si valeur non numérique
 107   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 108   2          {
 109   3            return 0;
 110   3          }
 111   2          
 112   2          // Si pas dans l'intervalle de valeur acceptées
 113   2          if(motor_speed < 0 || motor_speed > 100)
 114   2          {
 115   3            return 0;
 116   3          }
C51 COMPILER V9.55   COMMANDS                                                              03/17/2019 13:26:14 PAGE 3   

 117   2          
 118   2          cmd_packet->commands->Vitesse = motor_speed;
 119   2        }else{
 120   2          if(cmd_packet->commands->Vitesse == 0)
 121   2          {
 122   3            cmd_packet->commands->Vitesse = motor_speed;
 123   3          }
 124   2        }
 125   1        return 1;
 126   1      }
 127          
 128          byte move_backward_cmd(CMD_PACKET* cmd_packet)
 129          {
 130   1        int motor_speed = 20;
 131   1        
 132   1        if(cmd_packet->cmd_size > 1)
 133   1        {
 134   2          return 0;
 135   2        }
 136   1          
 137   1        cmd_packet->commands->Etat_Mouvement = Reculer;
 138   1      
 139   1        if(cmd_packet->cmd_size == 1)
 140   1        {
 141   2          // Si valeur non numérique
 142   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 143   2          {
 144   3            return 0;
 145   3          }
 146   2          
 147   2          // Si pas dans l'intervalle de valeur acceptées
 148   2          if(motor_speed < 0 || motor_speed > 100)
 149   2          {
 150   3            return 0;
 151   3          }
 152   2          
 153   2          cmd_packet->commands->Vitesse = motor_speed;
 154   2        }else{
 155   2          if(cmd_packet->commands->Vitesse == 0)
 156   2          {
 157   3            cmd_packet->commands->Vitesse = motor_speed;
 158   3          }
 159   2        }
 160   1        return 1;
 161   1      }
 162          
 163          byte move_stop_cmd(CMD_PACKET* cmd_packet)
 164          { 
 165   1        if(cmd_packet->cmd_size != 0)
 166   1        {
 167   2          return 0;
 168   2        }
 169   1        cmd_packet->commands->Vitesse = Stopper;
 170   1        return 1;
 171   1      }
 172          
 173          byte rigth_rotation_cmd(CMD_PACKET* cmd_packet)
 174          {
 175   1        if(cmd_packet->cmd_size != 0)
 176   1        {
 177   2          return 0;
 178   2        }
C51 COMPILER V9.55   COMMANDS                                                              03/17/2019 13:26:14 PAGE 4   

 179   1        
 180   1        cmd_packet->commands->Etat_Mouvement = Rot_90D;
 181   1        return 1;
 182   1      }
 183          
 184          byte left_rotation_cmd(CMD_PACKET* cmd_packet)
 185          {
 186   1        if(cmd_packet->cmd_size != 0)
 187   1        {
 188   2          return 0;
 189   2        }
 190   1        
 191   1        cmd_packet->commands->Etat_Mouvement = Rot_90G;
 192   1        return 1;
 193   1      }
 194          
 195          byte complete_rotation_cmd(CMD_PACKET* cmd_packet)
 196          {
 197   1        if(cmd_packet->cmd_size > 1)
 198   1        {
 199   2          return 0;
 200   2        }
 201   1      
 202   1        if(cmd_packet->cmd_size == 1)
 203   1        {
 204   2          
 205   2          if(strcmp((cmd_packet->commands_data + 1), "D") == 0 
 206   2            || strcmp((cmd_packet->commands_data + 1), "G") == 0)
 207   2          {
 208   3            switch( (*(cmd_packet->commands_data + 1)) )
 209   3            {
 210   4              case 'D':
 211   4                cmd_packet->commands->Etat_Mouvement = Rot_180D;
 212   4                break;
 213   4              default :
 214   4                cmd_packet->commands->Etat_Mouvement = Rot_180G;
 215   4                break;
 216   4            }
 217   3          }else{
 218   3            return 0;
 219   3          }
 220   2      
 221   2        }else{
 222   2          cmd_packet->commands->Etat_Mouvement = Rot_180D;
 223   2        }
 224   1        return 1;
 225   1      }
 226          
 227          byte angle_rotation_cmd(CMD_PACKET* cmd_packet)
 228          {
 229   1        unsigned int angle = 90;
 230   1        
 231   1        if(cmd_packet->cmd_size != 2)
 232   1        {
 233   2          return 0;
 234   2        }
 235   1        
 236   1        if(strcmp((cmd_packet->commands_data + 1), "D") == 0 
 237   1            || strcmp((cmd_packet->commands_data + 1), "G") == 0)
 238   1        {
 239   2          switch( (*(cmd_packet->commands_data + 1)) )
 240   2          {
C51 COMPILER V9.55   COMMANDS                                                              03/17/2019 13:26:14 PAGE 5   

 241   3            case 'D':
 242   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 243   3              break;
 244   3            default :
 245   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 246   3              break;
 247   3          }
 248   2          
 249   2          if(sscanf((cmd_packet->commands_data + (2 * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 250   2          {
 251   3            return 0;
 252   3          }
 253   2          
 254   2          cmd_packet->commands->Angle = (int)(100 * angle);
 255   2        }else{
 256   2          return 0;
 257   2        }
 258   1        return 1;
 259   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1396    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----      28
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
