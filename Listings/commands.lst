C51 COMPILER V9.55   COMMANDS                                                              03/10/2019 17:34:44 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COMMANDS
OBJECT MODULE PLACED IN .\Objects\commands.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\commands.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\commands.lst) TABS(2) OBJECT(.\Objects\commands.obj)

line level    source

   1          #include "commands.h"
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          byte args_valid(CMD_PACKET* cmd_packet)
   7          {
   8   1        byte cmd_data_ptr = 0, agrs_ptr = 0;
   9   1        byte arg_found = 0;
  10   1        
  11   1        if(cmd_packet->cmd_size == 0)
  12   1        {
  13   2          return 1;
  14   2        }
  15   1        
  16   1        // Lorsqu'une commande contient des args (ie sargs_size != 0), le nom des args
  17   1        // sont toujours sur un index impair dans command_data
  18   1        
  19   1        // On parcour tous les agrs entrés par l'user
  20   1        for(cmd_data_ptr = 1; cmd_data_ptr < cmd_packet->cmd_size; cmd_data_ptr+=2)
  21   1        {
  22   2          // On compare chaque arg avec la liste des args dispo avec la commande
  23   2          for(agrs_ptr = 0; agrs_ptr < cmd_packet->args_size ; agrs_ptr++)
  24   2          {
  25   3            // Si l'arg est valide, on test le suivant entré par l'user
  26   3            if(strcmp((cmd_packet->commands_data + cmd_data_ptr), (cmd_packet->args_label + agrs_ptr) ) == 0)
*** WARNING C182 IN LINE 26 OF src\commands.c: pointer to different objects
*** WARNING C182 IN LINE 26 OF src\commands.c: pointer to different objects
  27   3            {
  28   4              arg_found = 1;
  29   4              break;
  30   4            }
  31   3          }
  32   2          
  33   2          // Si arg pas dans la liste des arg disponnible, erreur de cmd
  34   2          if(arg_found == 0)
  35   2          {
  36   3            return 0;
  37   3          }else{
  38   3            arg_found = 0;
  39   3          }
  40   2        }
  41   1        
  42   1        return 1;
  43   1        
  44   1      }
  45          
  46          void default_process(CMD_PACKET* cmd_packet)
  47          {
  48   1        //printf("Non-implemented command !!");
  49   1      }
*** WARNING C280 IN LINE 46 OF src\commands.c: 'cmd_packet': unreferenced local variable
  50          
  51          /*
C51 COMPILER V9.55   COMMANDS                                                              03/10/2019 17:34:44 PAGE 2   

  52            Commande de démarage de l'épreuve : D [Numéro Epreuve]
  53            Si aucun paramètre rentré, alors on démarre à l'épreuve 1
  54          */
  55          void start_test(CMD_PACKET* cmd_packet)
  56          {
  57   1        byte epreuve_index = 1;
  58   1      
  59   1        // Si le paramètre correspondant au numéro d'épreuve est présent
  60   1        if(cmd_packet->cmd_size == 1)
  61   1        {
  62   2          epreuve_index = atoi(*(cmd_packet->commands_data + 1));
  63   2          cmd_packet->commands->Etat_Epreuve = (enum Epreuve)epreuve_index;
  64   2        }
  65   1        else
  66   1        {
  67   2          cmd_packet->commands->Etat_Epreuve = epreuve1;
  68   2        }
  69   1      
  70   1      }
  71          
  72          
  73          void safety_break(CMD_PACKET* cmd_packet)
  74          {
  75   1        cmd_packet->commands->Etat_Epreuve = Stop_Urgence;
  76   1      }
  77          
  78          void set_default_speed(CMD_PACKET* cmd_packet)
  79          {
  80   1        byte motor_speed = 20;
  81   1      
  82   1        motor_speed = atoi(*(cmd_packet->commands_data + 1));
  83   1        motor_speed = (byte) max(5, min(motor_speed, 100));
  84   1        
  85   1        cmd_packet->commands->Vitesse = motor_speed;
  86   1      
  87   1        
  88   1      }
  89          
  90          void move_forward(CMD_PACKET* cmd_packet)
  91          {
  92   1        byte motor_speed = 20;
  93   1          
  94   1        cmd_packet->commands->Etat_Mouvement = Avancer;
  95   1      
  96   1        if(cmd_packet->cmd_size == 1)
  97   1        {
  98   2          motor_speed = atoi(*(cmd_packet->commands_data + 1));
  99   2          motor_speed = max(5, min(motor_speed, 100));
 100   2          cmd_packet->commands->Vitesse = motor_speed;
 101   2        }else{
 102   2          if(cmd_packet->commands->Vitesse == 0)
 103   2          {
 104   3            cmd_packet->commands->Vitesse = motor_speed;
 105   3          }
 106   2        }
 107   1        
 108   1      }
 109          
 110          void move_backward(CMD_PACKET* cmd_packet)
 111          {
 112   1        byte motor_speed = 20;
 113   1          
C51 COMPILER V9.55   COMMANDS                                                              03/10/2019 17:34:44 PAGE 3   

 114   1        cmd_packet->commands->Etat_Mouvement = Reculer;
 115   1      
 116   1        if(cmd_packet->cmd_size == 1)
 117   1        {
 118   2          motor_speed = atoi(*(cmd_packet->commands_data + 1));
 119   2          motor_speed = max(5, min(motor_speed, 100));
 120   2          cmd_packet->commands->Vitesse = motor_speed;
 121   2        }else{
 122   2          if(cmd_packet->commands->Vitesse == 0)
 123   2          {
 124   3            cmd_packet->commands->Vitesse = motor_speed;
 125   3          }
 126   2        }
 127   1        
 128   1      }
 129          
 130          void move_stop(CMD_PACKET* cmd_packet)
 131          { 
 132   1        cmd_packet->commands->Vitesse = Stopper;
 133   1      
 134   1      }
 135          
 136          void rigth_rotation(CMD_PACKET* cmd_packet)
 137          {
 138   1        cmd_packet->commands->Etat_Mouvement = Rot_90D;
 139   1        
 140   1      }
 141          
 142          void left_rotation(CMD_PACKET* cmd_packet)
 143          {
 144   1        cmd_packet->commands->Etat_Mouvement = Rot_90G;
 145   1        
 146   1      }
 147          
 148          void complete_rotation(CMD_PACKET* cmd_packet)
 149          {
 150   1        if(cmd_packet->cmd_size == 1)
 151   1        {
 152   2          switch( *(*(cmd_packet->commands_data + 1)) )
 153   2          {
 154   3            case 'D':
 155   3              cmd_packet->commands->Etat_Mouvement = Rot_180D;
 156   3              break;
 157   3            default :
 158   3              cmd_packet->commands->Etat_Mouvement = Rot_180G;
 159   3              break;
 160   3          }
 161   2        }else{
 162   2          cmd_packet->commands->Etat_Mouvement = Rot_180D;
 163   2        }
 164   1          
 165   1      }
 166          
 167          void angle_rotation(CMD_PACKET* cmd_packet)
 168          {
 169   1        unsigned int angle = 90;
 170   1        
 171   1        // A revoir. La commande RA 75 ne marche pas ....
 172   1        // Il faut soit RA, RA D , RA G, RA D:valeur, mais pas RA valeur....
 173   1        if(cmd_packet->cmd_size == 1)
 174   1        {
 175   2          switch( *(*(cmd_packet->commands_data + 1)) )
C51 COMPILER V9.55   COMMANDS                                                              03/10/2019 17:34:44 PAGE 4   

 176   2          {
 177   3            case 'D':
 178   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 179   3              break;
 180   3            default :
 181   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 182   3              break;
 183   3          }
 184   2          cmd_packet->commands->Angle = (100 * angle);
 185   2        }
 186   1        else if(cmd_packet->cmd_size == 2)
 187   1        {
 188   2          switch( *(*(cmd_packet->commands_data + 1)) )
 189   2          {
 190   3            case 'D':
 191   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 192   3              break;
 193   3            default :
 194   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 195   3              break;
 196   3          }
 197   2          
 198   2          sscanf(*(cmd_packet->commands_data + 2), "%d", angle);
 199   2          angle = max(0, min(angle, 180));
 200   2          cmd_packet->commands->Angle = (int)(100 * angle);
 201   2        }else{
 202   2          cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 203   2          cmd_packet->commands->Angle = (100 * angle);
 204   2        }
 205   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1227    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =   ----      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
