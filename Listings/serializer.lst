C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE SERIALIZER
OBJECT MODULE PLACED IN .\Objects\serializer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\serializer.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\serializer.lst) TABS(2) OBJECT(.\Objects\serializer.obj)

line level    source

   1          #include "serializer.h"
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include "motion.h"
   5          
   6          
   7          const SERIALIZER_FSM_PROCESS serializer_state_machine[6] = {
   8              {IDLE, &idle},
   9              {TRANSLATE, &translate},
  10              {MOVETO, &moveTo},
  11              {ROTATE, &rotate},
  12              {NAVIGATE, &navigate},
  13              {STOP, &stop}
  14          };
  15          
  16          /* Etat courant de la machine d'Etat */
  17          volatile SERIALIZER_STATE serializer_state = IDLE;
  18          
  19          byte is_processing = 0;
  20          
  21          byte is_navigating = 0;
  22          
  23          int pids_timer = 0;
  24          
  25          PTS_2DA robot_position = {0, 0, 0, 0};
  26          
  27          /*
  28          #############################################################################
  29                  UART1 related function for µP 8051F020
  30          #############################################################################
  31          */
  32          
  33          /**
  34            8051 µP :
  35            Initialize devices for commands_parser : UART0 and Timer 2
  36          **/
  37          byte init_serializer_UART1()
  38          {
  39   1        
  40   1        /****** INIT UART1 *****/
  41   1        SCON1 = 0x50;
  42   1        
  43   1        // Réglage timer 4
  44   1        T4CON = 0x3D; // Baud Generator for UART1 + Enable TR4
  45   1        
  46   1        RCAP4L = 0xDC;  // Reload value for BaudRate 19200
  47   1        RCAP4H = 0xFF;
  48   1        
  49   1        return 0;
  50   1      }
  51          
  52          void serializer_receive(byte* read_byte)
  53          {
  54   1        if( (SCON1 & 0x01) == 1)
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 2   

  55   1        {
  56   2          *read_byte = SBUF1;
  57   2          SCON1 &= 0xFE;  // Remise à 0 de RI1
  58   2        }else{
  59   2          *read_byte = '*';
  60   2        }
  61   1      }
  62          
  63          void serializer_send(byte ch)
  64          {
  65   1        SBUF1 = ch;
  66   1        while( (SCON1 & 0x02) == 0){} // Tant que TI1 == 0
  67   1        SCON1 &= 0xFD;  // Remise à 0 de TI1
  68   1      }
  69          
  70          void UART_send(byte ch)
  71          {
  72   1        SBUF0 = ch;
  73   1        while(TI0 == 0){}
  74   1        TI0 = 0;
  75   1      }
  76          
  77          void serializer_print(char* str)
  78          {
  79   1        byte i = 0;
  80   1        for(i = 0 ; i < strlen(str); i++)
  81   1        {
  82   2          //UART_send(*(str+i));
  83   2          serializer_send(*(str+i));
  84   2        }
  85   1        
  86   1        serializer_send(0x0D);
  87   1        //UART_send('\n');
  88   1      }
  89          
  90          void serializer_init_serial()
  91          {
  92   1        char c = 0;
  93   1        do
  94   1        {
  95   2          serializer_receive(&c);
  96   2          //UART_send(c);
  97   2        }while(c != END_RSLT_BYTE);
  98   1        
  99   1      }
 100          
 101          void serializer_clear_serial()
 102          {
 103   1        char c = 0;
 104   1        //UART_send('!');
 105   1        do
 106   1        {
 107   2          serializer_receive(&c);
 108   2          //UART_send(c);
 109   2        }while(c != END_RSLT_BYTE);
 110   1        //UART_send('\n');
 111   1      }
 112          
 113          /*
 114          #############################################################################
 115                  Serializer related functions
 116          #############################################################################
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 3   

 117          */
 118          
 119          //void serializer_process(OUT_M1* cmd)
 120          void serializer_process(PARSER_RESULT* parser)
 121          {
 122   1        PTS_2DA pts = {1, 0, 0, 0};
 123   1        
 124   1        // Si une commande de mvt est demandé
 125   1        if(parser->commands->Etat_Mouvement == Stopper)
 126   1        {
 127   2          serializer_state = STOP;
 128   2          is_processing = 0;
 129   2          parser->commands->Etat_Mouvement = Mouvement_non;
 130   2        }
 131   1        else if(parser->commands->Etat_Mouvement != Mouvement_non)
 132   1        {
 133   2          // Transition d'état de la FSM
 134   2          switch(serializer_state)
 135   2          {
 136   3            case IDLE:
 137   3              idle_next_state(parser->commands, &pts);
 138   3              break;
 139   3            
 140   3            case TRANSLATE:
 141   3              if(is_processing == 1)
 142   3              {
 143   4                serializer_state = TRANSLATE;
 144   4              }
 145   3              else
 146   3              {
 147   4                serializer_state = STOP;
 148   4              }
 149   3              break;
 150   3              
 151   3            case ROTATE:
 152   3              // If already rotating
 153   3              if(is_processing == 1)
 154   3              {
 155   4                serializer_state = ROTATE;
 156   4              }
 157   3              else
 158   3              {
 159   4                serializer_state = STOP;
 160   4              }
 161   3              break;
 162   3              
 163   3            case NAVIGATE:
 164   3              if(is_navigating == 1)
 165   3              {
 166   4                serializer_state = NAVIGATE;
 167   4              }
 168   3              else
 169   3              {
 170   4                parser->informations->Etat_BUT_Mouvement = BUT_Atteint_oui;
 171   4                parser->commands->Etat_Mouvement = Mouvement_non;
 172   4                robot_position.angle = 1 * parser->commands->Angle;
 173   4                robot_position.x = parser->commands->Coord_X;
 174   4                robot_position.y = parser->commands->Coord_Y;
 175   4                robot_position.speed = parser->commands->Vitesse;
 176   4                serializer_state = IDLE;
 177   4              }
 178   3              break;
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 4   

 179   3              
 180   3            case MOVETO:
 181   3              if(is_processing == 1)
 182   3              {
 183   4                serializer_state = MOVETO;
 184   4              }
 185   3              else
 186   3              {
 187   4                serializer_state = STOP;
 188   4              }
 189   3              break;
 190   3              
 191   3            case STOP:
 192   3              if(is_navigating == 0)
 193   3              {
 194   4                serializer_state = IDLE;
 195   4                parser->commands->Etat_Mouvement = Mouvement_non;
 196   4              }
 197   3              else{
 198   4                serializer_state = NAVIGATE;
 199   4              }
 200   3              break;
 201   3            
 202   3            default:
 203   3              serializer_state = STOP;
 204   3              break;
 205   3            
 206   3          }
 207   2          
 208   2        }else{
 209   2          serializer_state = IDLE;
 210   2        }
 211   1        
 212   1        serializer_state_machine[serializer_state].state_process(&pts);
 213   1      }
 214          
 215          void idle_next_state(OUT_M1* cmd, PTS_2DA* pts)
 216          {
 217   1        switch(cmd->Etat_Mouvement)
 218   1        {
 219   2            case Avancer:
 220   2              serializer_state = TRANSLATE;
 221   2              pts->x = 1;
 222   2              pts->speed = cmd->Vitesse;
 223   2              break;
 224   2            
 225   2            case Reculer:
 226   2              serializer_state = TRANSLATE;
 227   2              pts->x = -1;
 228   2              pts->speed = cmd->Vitesse;
 229   2              break;
 230   2            
 231   2            case Stopper:
 232   2              serializer_state = STOP;
 233   2              pts->x = 0;
 234   2              pts->speed = 0;
 235   2              //serializer_print("mogo 1:0 2:0");
 236   2              break;
 237   2      
 238   2            case Rot_90D:
 239   2              serializer_state = ROTATE;
 240   2              pts->angle = (-1) * 90;
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 5   

 241   2              pts->speed = 20;
 242   2              break;
 243   2            
 244   2            case Rot_90G:
 245   2              serializer_state = ROTATE;
 246   2              pts->angle = 90;
 247   2              pts->speed = 20;
 248   2              break;
 249   2            
 250   2            case Rot_180D:
 251   2              serializer_state = ROTATE;
 252   2              pts->angle = -180;
 253   2              pts->speed = 20;
 254   2              break;
 255   2            
 256   2            case Rot_180G:
 257   2              serializer_state = ROTATE;
 258   2              pts->angle = 180;
 259   2              pts->speed = 20;
 260   2              break;
 261   2      
 262   2            case Rot_AngD:
 263   2              serializer_state = ROTATE;
 264   2              pts->angle = -1 * cmd->Angle;
 265   2              pts->speed = 20;
 266   2              break;
 267   2      
 268   2            case Rot_AngG:
 269   2              serializer_state = ROTATE;
 270   2              pts->angle = 1 * cmd->Angle;
 271   2              pts->speed = 20;
 272   2              break;
 273   2            
 274   2            case Depl_Coord:
 275   2              serializer_state = NAVIGATE;
 276   2              pts->angle = 1 * cmd->Angle;
 277   2              pts->x = cmd->Coord_X;
 278   2              pts->y = cmd->Coord_Y;
 279   2              pts->speed = cmd->Vitesse;
 280   2              break;
 281   2            
 282   2            default:
 283   2              serializer_state = IDLE;
 284   2              break;
 285   2          }
 286   1        
 287   1      }
 288          
 289          void idle(PTS_2DA* pts)
 290          {
 291   1        // Nothing to do
 292   1      }
*** WARNING C280 IN LINE 289 OF src\serializer.c: 'pts': unreferenced local variable
 293          
 294          
 295          void translate(PTS_2DA* pts)
 296          {
 297   1        char speed = 10;
 298   1        
 299   1        if(is_processing == 0)
 300   1        {
 301   2          if(pts->speed != 0)
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 6   

 302   2          {
 303   3            speed = pts->speed;
 304   3          }
 305   2        
 306   2          setMotors(pts->x * speed, pts->x * speed);
 307   2          is_processing = 1;
 308   2        }
 309   1        
 310   1      }
 311          
 312          void rotate(PTS_2DA* pts)
 313          {
 314   1        char sens = 0;
 315   1        
 316   1        if(is_processing == 0)
 317   1        {
 318   2          //clear_encoder();
 319   2          //getEncoderDistance(LEFT);
 320   2          moveAngle(pts->angle);
 321   2          is_processing = 1;
 322   2        }
 323   1        else{
 324   2          
 325   2          if(pids_timer >= 5000)
 326   2          {
 327   3            is_processing = is_PID_processing();
 328   3            pids_timer = 0;
 329   3          }
 330   2          else{
 331   3            pids_timer++;
 332   3          }
 333   2        }
 334   1      }
 335          
 336          void navigate(PTS_2DA* pts)
 337          {
 338   1        static byte navigation_step = 0;
 339   1        static char target_angle = 0;
 340   1        PTS_2DA temp_pts = {0, 0, 0, 0};
 341   1        
 342   1        switch(navigation_step)
 343   1        {
 344   2          case 0:
 345   2            // Start Navigation Flag
 346   2            is_navigating = 1;
 347   2            pts->x = 10;
 348   2            pts->y = 10;
 349   2            target_angle = angle_target(&(robot_position.angle), pts->x, pts->y);
 350   2            temp_pts.angle = delta_angle(&(robot_position.angle), &target_angle);
*** WARNING C182 IN LINE 350 OF src\serializer.c: pointer to different objects
 351   2            //temp_pts.angle = delta_angle(&(pts->angle), &(robot_position.angle) );
 352   2            serializer_state = ROTATE;
 353   2            navigation_step++;
 354   2            rotate(&temp_pts);
 355   2            break;
 356   2          
 357   2          case 1:
 358   2            /*
 359   2            temp_pts.x = (robot_position.x - pts->x);
 360   2            temp_pts.y = (robot_position.y - pts->y);
 361   2            temp_pts.speed = pts->speed;
 362   2          */
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 7   

 363   2            temp_pts.x = 10;
 364   2            temp_pts.y = 10;
 365   2            temp_pts.speed = 20;
 366   2            serializer_state = MOVETO;
 367   2            navigation_step++;
 368   2            moveTo(&temp_pts);
 369   2            break;
 370   2          
 371   2          case 2:
 372   2            temp_pts.angle = delta_angle(&target_angle, &(robot_position.angle) );
*** WARNING C182 IN LINE 372 OF src\serializer.c: pointer to different objects
 373   2            serializer_state = ROTATE;
 374   2            navigation_step++;
 375   2            rotate(&temp_pts);
 376   2            break;
 377   2          
 378   2          case 3:
 379   2            is_navigating = 0;
 380   2            navigation_step = 0;
 381   2            target_angle = 0;
 382   2            break;
 383   2          
 384   2        }
 385   1        
 386   1        
 387   1      }
 388          
 389          void setMotors(int mtr_speed_1, int mtr_speed_2)
 390          {
 391   1        char cmd[MOGO_CMD_SIZE];
 392   1        
 393   1        sprintf(cmd, "mogo 1:%d 2:%d", mtr_speed_1, mtr_speed_2);
 394   1      
 395   1        serializer_print(cmd);
 396   1        
 397   1        serializer_clear_serial();
 398   1      }
 399          
 400          void moveTo(PTS_2DA* pts)
 401          {
 402   1        char cmd[DIGO_CMD_SIZE];
 403   1        int distance_in_tick = 0;
 404   1        
 405   1        if(is_processing == 0)
 406   1        {
 407   2          distance_in_tick = distance(pts->x, pts->y);
 408   2          distance_in_tick = (int)(3.3 * 100 * distance_in_tick);
 409   2          
 410   2          // TODO : Pour le moment, la vitesse du digo est de 28%, donc pas la valeur set par TV
 411   2          // On est obligé car ce 28 est fixé par le DPID et le VPID du sérializer ...
 412   2          sprintf(cmd, "digo 1:%d:28 2:%d:28", distance_in_tick, distance_in_tick);
 413   2        
 414   2          serializer_print(cmd);
 415   2          serializer_clear_serial();
 416   2          
 417   2          is_processing = 1;
 418   2        } 
 419   1        else{
 420   2          
 421   2          if(pids_timer >= 5000)
 422   2          {
 423   3            is_processing = is_PID_processing();
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 8   

 424   3            pids_timer = 0;
 425   3          }
 426   2          else{
 427   3            pids_timer++;
 428   3          }
 429   2        }
 430   1      }
 431          
 432          void moveAngle(int angle)
 433          {
 434   1        char cmd[DIGO_CMD_SIZE];
 435   1        int distance_in_tick = 0, r_dist = 0;
 436   1        
 437   1        distance_in_tick = ANGLE_2_DIST(angle);
 438   1        
 439   1        r_dist = (-1) * distance_in_tick;
 440   1        
 441   1        sprintf(cmd, "digo 1:%d:20 2:%d:20", distance_in_tick, r_dist);
 442   1        serializer_print(cmd);
 443   1        serializer_clear_serial();
 444   1        
 445   1        //memset(cmd, 0, DIGO_CMD_SIZE);
 446   1      }
 447          
 448          void stop(PTS_2DA* pts)
 449          {
 450   1        serializer_print("stop"); 
 451   1        serializer_clear_serial();
 452   1        //clear_encoder();
 453   1      }
*** WARNING C280 IN LINE 448 OF src\serializer.c: 'pts': unreferenced local variable
 454          
 455          int getRawEncoders(ENCODER_ID encoder_id)
 456          {
 457   1        int enc_value = 0;
 458   1        char result[ENC_RSLT_SIZE];
 459   1        char c = 0;
 460   1        byte ptr = 0;
 461   1        
 462   1        if(encoder_id == LEFT)
 463   1        {
 464   2          serializer_print("getenc 1");
 465   2        }
 466   1        else{
 467   2          serializer_print("getenc 2");
 468   2        }
 469   1        
 470   1        do
 471   1        {
 472   2          serializer_receive(&c);
 473   2          result[ptr] = c;
 474   2          ptr++;
 475   2        }while(c != END_RSLT_BYTE);
 476   1        
 477   1        sscanf(result, "%d", &enc_value);
 478   1        
 479   1        return enc_value;
 480   1      }
 481          
 482          int getEncoderDistance(ENCODER_ID encoder_id)
 483          {
 484   1        int enc_value = 0;
C51 COMPILER V9.55   SERIALIZER                                                            03/29/2019 14:09:49 PAGE 9   

 485   1        
 486   1        enc_value = getRawEncoders(encoder_id);
 487   1        
 488   1        return ENC_2_MM(enc_value);
 489   1      }
 490          
 491          void clear_encoder()
 492          {
 493   1        char result[PID_RSLT_SIZE];
 494   1        char ptr = 0, c = 0;
 495   1        
 496   1        serializer_print("clrenc 1 2");
 497   1      
 498   1        do
 499   1        {
 500   2          serializer_receive(&c);
 501   2          result[ptr] = c;
 502   2          ptr++;
 503   2        }while(c != END_RSLT_BYTE);
 504   1        
 505   1        
 506   1      }
 507          
 508          char is_PID_processing()
 509          {
 510   1        char result[PID_RSLT_SIZE];
 511   1        int pid_state = 1;
 512   1        char ptr = 0;
 513   1        byte c = 0;
 514   1        
 515   1        serializer_print("pids");
 516   1          
 517   1        do
 518   1        {
 519   2          serializer_receive(&c);
 520   2          if(c != '*')
 521   2          {
 522   3            result[ptr] = c;
 523   3            ptr++;
 524   3            UART_send(c);
 525   3          }
 526   2        }while(c != END_RSLT_BYTE);
 527   1        
 528   1        sscanf(result, "%d", &pid_state);
 529   1        
 530   1        memset(result, 0, PID_RSLT_SIZE);
 531   1        
 532   1        return (char)pid_state;
 533   1      }
 534          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3398    ----
   CONSTANT SIZE    =    109    ----
   XDATA SIZE       =     36     226
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
