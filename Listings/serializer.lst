C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE SERIALIZER
OBJECT MODULE PLACED IN .\Objects\serializer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\serializer.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\serializer.lst) TABS(2) OBJECT(.\Objects\serializer.obj)

line level    source

   1          #include "serializer.h"
   2          #include <string.h>
   3          #include <stdio.h>
   4          
   5          const SERIALIZER_FSM_PROCESS serializer_state_machine[5] = {
   6              {IDLE, &idle},
   7              {TRANSLATE, &translate},
   8              {ROTATE, &rotate},
   9              {NAVIGATE, NULL},
  10              {STOP, &stop}
  11          };
  12          
  13          /* Etat courant de la machine d'Etat */
  14          volatile SERIALIZER_STATE serializer_state = IDLE;
  15          
  16          byte is_processing = 0;
  17          
  18          /*
  19          #############################################################################
  20                  UART1 related function for µP 8051F020
  21          #############################################################################
  22          */
  23          
  24          /**
  25            8051 µP :
  26            Initialize devices for commands_parser : UART0 and Timer 2
  27          **/
  28          byte init_serializer_UART1()
  29          {
  30   1        
  31   1        /****** INIT UART1 *****/
  32   1        SCON1 = 0x50;
  33   1        
  34   1        // Réglage timer 4
  35   1        T4CON = 0x3D; // Baud Generator for UART1 + Enable TR4
  36   1        
  37   1        RCAP4L = 0xDC;  // Reload value for BaudRate 19200
  38   1        RCAP4H = 0xFF;
  39   1        
  40   1        return 0;
  41   1      }
  42          
  43          void serializer_receive(byte* read_byte)
  44          {
  45   1        if( (SCON1 & 0x01) == 1)
  46   1        {
  47   2          *read_byte = SBUF1;
  48   2          SCON1 &= 0xFE;  // Remise à 0 de RI1
  49   2        }else{
  50   2          *read_byte = '*';
  51   2        }
  52   1      }
  53          
  54          void serializer_send(byte ch)
C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 2   

  55          {
  56   1        SBUF1 = ch;
  57   1        while( (SCON1 & 0x02) == 0){} // Tant que TI1 == 0
  58   1        SCON1 &= 0xFD;  // Remise à 0 de TI1
  59   1      }
  60          
  61          void UART_send(byte ch)
  62          {
  63   1        SBUF0 = ch;
  64   1        while(TI0 == 0){}
  65   1        TI0 = 0;
  66   1      }
  67          
  68          void serializer_print(char* str)
  69          {
  70   1        byte i = 0;
  71   1        for(i = 0 ; i < strlen(str); i++)
  72   1        {
  73   2          UART_send(*(str+i));
  74   2          serializer_send(*(str+i));
  75   2        }
  76   1        
  77   1        serializer_send(0x0D);
  78   1        UART_send('\n');
  79   1      }
  80          
  81          void serializer_init_serial()
  82          {
  83   1        char c = 0;
  84   1        do
  85   1        {
  86   2          serializer_receive(&c);
  87   2          UART_send(c);
  88   2        }while(c != END_RSLT_BYTE);
  89   1        
  90   1      }
  91          
  92          void serializer_clear_serial()
  93          {
  94   1        char c = 0;
  95   1        //UART_send('!');
  96   1        do
  97   1        {
  98   2          serializer_receive(&c);
  99   2        }while(c != END_RSLT_BYTE);
 100   1        
 101   1      }
 102          
 103          /*
 104          #############################################################################
 105                  Serializer related functions
 106          #############################################################################
 107          */
 108          
 109          void serializer_process(OUT_M1* cmd)
 110          {
 111   1        PTS_2DA pts = {1, 0, 0, 0};
 112   1        
 113   1        // Si une commande de mvt est demandé
 114   1        if(cmd->Etat_Mouvement == Stopper)
 115   1        {
 116   2          serializer_state = STOP;
C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 3   

 117   2          is_processing = 0;
 118   2          cmd->Etat_Mouvement = Mouvement_non;
 119   2        }
 120   1        else if(cmd->Etat_Mouvement != Mouvement_non)
 121   1        {
 122   2          // Transition d'état de la FSM
 123   2          switch(serializer_state)
 124   2          {
 125   3            case IDLE:
 126   3              idle_next_state(cmd, &pts);
 127   3              break;
 128   3            
 129   3            case TRANSLATE:
 130   3              if(is_processing == 1)
 131   3              {
 132   4                serializer_state = TRANSLATE;
 133   4              }
 134   3              else
 135   3              {
 136   4                serializer_state = STOP;
 137   4              }
 138   3              break;
 139   3              
 140   3            case ROTATE:
 141   3              if(is_processing == 1)
 142   3              {
 143   4                serializer_state = ROTATE;
 144   4              }
 145   3              else
 146   3              {
 147   4                serializer_state = STOP;
 148   4              }
 149   3              break;
 150   3              
 151   3            case STOP:
 152   3              serializer_state = IDLE;
 153   3              cmd->Etat_Mouvement = Mouvement_non;
 154   3              break;
 155   3            
 156   3            default:
 157   3              serializer_state = STOP;
 158   3              break;
 159   3            
 160   3          }
 161   2          
 162   2        }else{
 163   2          serializer_state = IDLE;
 164   2        }
 165   1        
 166   1        serializer_state_machine[serializer_state].state_process(&pts);
 167   1      }
 168          
 169          void idle_next_state(OUT_M1* cmd, PTS_2DA* pts)
 170          {
 171   1        switch(cmd->Etat_Mouvement)
 172   1        {
 173   2            case Avancer:
 174   2              serializer_state = TRANSLATE;
 175   2              pts->x = 1;
 176   2              pts->speed = cmd->Vitesse;
 177   2              break;
 178   2            
C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 4   

 179   2            case Reculer:
 180   2              serializer_state = TRANSLATE;
 181   2              pts->x = -1;
 182   2              pts->speed = cmd->Vitesse;
 183   2              break;
 184   2            
 185   2            case Stopper:
 186   2              serializer_state = STOP;
 187   2              pts->x = 0;
 188   2              pts->speed = 0;
 189   2              //serializer_print("mogo 1:0 2:0");
 190   2              break;
 191   2      
 192   2            case Rot_90D:
 193   2              serializer_state = ROTATE;
 194   2              pts->angle = -90;
 195   2              pts->speed = 20;
 196   2              break;
 197   2            
 198   2            case Rot_90G:
 199   2              serializer_state = ROTATE;
 200   2              pts->angle = 90;
 201   2              pts->speed = 20;
 202   2              break;
 203   2            
 204   2            case Rot_180D:
 205   2              serializer_state = ROTATE;
 206   2              pts->angle = -180;
 207   2              pts->speed = 20;
 208   2              break;
 209   2            
 210   2            case Rot_180G:
 211   2              serializer_state = ROTATE;
 212   2              pts->angle = 180;
 213   2              pts->speed = 20;
 214   2              break;
 215   2      
 216   2            case Rot_AngD:
 217   2              serializer_state = ROTATE;
 218   2              pts->angle = -1 * cmd->Angle;
 219   2              pts->speed = 20;
 220   2              break;
 221   2      
 222   2            case Rot_AngG:
 223   2              serializer_state = ROTATE;
 224   2              pts->angle = 1 * cmd->Angle;
 225   2              pts->speed = 20;
 226   2              break;
 227   2            
 228   2            default:
 229   2              serializer_state = IDLE;
 230   2              break;
 231   2          }
 232   1        
 233   1      }
 234          
 235          void idle(PTS_2DA* pts)
 236          {
 237   1        // Nothing to do
 238   1      }
*** WARNING C280 IN LINE 235 OF src\serializer.c: 'pts': unreferenced local variable
 239          
C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 5   

 240          
 241          void translate(PTS_2DA* pts)
 242          {
 243   1        char speed = 10;
 244   1        
 245   1        if(is_processing == 0)
 246   1        {
 247   2          if(pts->speed != 0)
 248   2          {
 249   3            speed = pts->speed;
 250   3          }
 251   2          
 252   2          setMotors(pts->x * speed, pts->x * speed);
 253   2          is_processing = 1;
 254   2        }
 255   1        
 256   1      }
 257          
 258          void rotate(PTS_2DA* pts)
 259          {
 260   1        char sens = 0;
 261   1        
 262   1        if(is_processing == 0)
 263   1        {
 264   2          moveAngle(pts->angle);
 265   2          is_processing = 1;
 266   2        }
 267   1        else{
 268   2          is_processing = is_PID_processing();
 269   2        }
 270   1      }
 271          
 272          void setMotors(int mtr_speed_1, int mtr_speed_2)
 273          {
 274   1        char cmd[MOGO_CMD_SIZE];
 275   1        
 276   1        sprintf(cmd, "mogo 1:%d 2:%d", mtr_speed_1, mtr_speed_2);
 277   1      
 278   1        serializer_print(cmd);
 279   1        
 280   1        serializer_clear_serial();
 281   1      }
 282          
 283          void moveAngle(float angle)
 284          {
 285   1        char cmd[DIGO_CMD_SIZE];
 286   1        int distance_in_tick = 0;
 287   1        
 288   1        distance_in_tick = (int)(ANGLE_2_DIST(angle));
 289   1        
 290   1        sprintf(cmd, "digo 1 : %d : 28 2 : %d : 28", -1 * distance_in_tick, distance_in_tick);
 291   1        serializer_print(cmd);
 292   1        serializer_clear_serial();
 293   1      }
 294          
 295          void stop(PTS_2DA* pts)
 296          {
 297   1        serializer_print("stop");
 298   1        serializer_clear_serial();
 299   1      }
*** WARNING C280 IN LINE 295 OF src\serializer.c: 'pts': unreferenced local variable
 300          
C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 6   

 301          int getRawEncoders(ENCODER_ID encoder_id)
 302          {
 303   1        int enc_value = 0;
 304   1        char result[ENC_RSLT_SIZE];
 305   1        char c = 0;
 306   1        byte ptr = 0;
 307   1        
 308   1        if(encoder_id == LEFT)
 309   1        {
 310   2          serializer_print("getenc 1");
 311   2        }
 312   1        else{
 313   2          serializer_print("getenc 2");
 314   2        }
 315   1        
 316   1        do
 317   1        {
 318   2          serializer_receive(&c);
 319   2          result[ptr] = c;
 320   2          ptr++;
 321   2        }while(c != END_RSLT_BYTE);
 322   1        
 323   1        sscanf(result, "%d", &enc_value);
 324   1        
 325   1        return enc_value;
 326   1      }
 327          
 328          int getEncoderDistance(ENCODER_ID encoder_id)
 329          {
 330   1        int enc_value = 0;
 331   1        
 332   1        enc_value = getRawEncoders(encoder_id);
 333   1        
 334   1        return ENC_2_MM(enc_value);
 335   1      }
 336          
 337          char is_PID_processing()
 338          {
 339   1        char result[PID_RSLT_SIZE];
 340   1        int pid_state = 0;
 341   1        char ptr = 0, c = 0;
 342   1      
 343   1        do
 344   1        {
 345   2          serializer_receive(&c);
 346   2          result[ptr] = c;
 347   2          ptr++;
 348   2        }while(c != END_RSLT_BYTE);
 349   1        
 350   1        sscanf(result, "%d", &pid_state);
 351   1        
 352   1        return (char)pid_state;
 353   1      }
 354          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2136    ----
   CONSTANT SIZE    =     77    ----
   XDATA SIZE       =     22     143
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.55   SERIALIZER                                                            03/17/2019 18:14:07 PAGE 7   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
