C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SERIALIZER
OBJECT MODULE PLACED IN .\Objects\serializer.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\serializer.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\serializer.lst) OBJECT(.\Objects\serializer.obj)

line level    source

   1          #include "serializer.h"
   2          #include <string.h>
   3          #include <stdio.h>
   4          
   5          const SERIALIZER_FSM_PROCESS serializer_state_machine[5] = {
   6              {IDLE, &idle},
   7              {TRANSLATE, &translate},
   8              {ROTATE, &rotate},
   9                          {NAVIGATE, NULL},
  10                          {STOP, &stop}
  11          };
  12          
  13          /* Etat courant de la machine d'Etat */
  14          volatile SERIALIZER_STATE serializer_state = IDLE;
  15          
  16          byte is_processing = 0;
  17          
  18          byte pid_is_processing = 0;
  19          
  20          int pids_timer = 0;
  21          
  22          /*
  23          #############################################################################
  24                  UART1 related function for µP 8051F020
  25          #############################################################################
  26          */
  27          
  28          /**
  29            8051 µP :
  30            Initialize devices for commands_parser : UART0 and Timer 2
  31          **/
  32          byte init_serializer_UART1()
  33          {
  34   1              
  35   1              /****** INIT UART1 *****/
  36   1              SCON1 = 0x50;
  37   1              
  38   1              // Réglage timer 4
  39   1              T4CON = 0x3D; // Baud Generator for UART1 + Enable TR4
  40   1              
  41   1              RCAP4L = 0xDC;  // Reload value for BaudRate 19200
  42   1              RCAP4H = 0xFF;
  43   1              
  44   1        return 0;
  45   1      }
  46          
  47          void serializer_receive(byte* read_byte)
  48          {
  49   1        if( (SCON1 & 0x01) == 1)
  50   1              {
  51   2                      *read_byte = SBUF1;
  52   2                      SCON1 &= 0xFE;  // Remise à 0 de RI1
  53   2              }else{
  54   2          *read_byte = '*';
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 2   

  55   2        }
  56   1      }
  57          
  58          void serializer_send(byte ch)
  59          {
  60   1              SBUF1 = ch;
  61   1              while( (SCON1 & 0x02) == 0){} // Tant que TI1 == 0
  62   1              SCON1 &= 0xFD;  // Remise à 0 de TI1
  63   1      }
  64          
  65          void UART_send(byte ch)
  66          {
  67   1              SBUF0 = ch;
  68   1              while(TI0 == 0){}
  69   1              TI0 = 0;
  70   1      }
  71          
  72          void serializer_print(char* str)
  73          {
  74   1        byte i = 0;
  75   1              for(i = 0 ; i < strlen(str); i++)
  76   1        {
  77   2          //UART_send(*(str+i));
  78   2                      serializer_send(*(str+i));
  79   2        }
  80   1              
  81   1              serializer_send(0x0D);
  82   1              //UART_send('\n');
  83   1      }
  84          
  85          void serializer_init_serial()
  86          {
  87   1              char c = 0;
  88   1              do
  89   1              {
  90   2                      serializer_receive(&c);
  91   2                      //UART_send(c);
  92   2              }while(c != END_RSLT_BYTE);
  93   1              
  94   1      }
  95          
  96          void serializer_clear_serial()
  97          {
  98   1              char c = 0;
  99   1              //UART_send('!');
 100   1              do
 101   1              {
 102   2                      serializer_receive(&c);
 103   2                      //UART_send(c);
 104   2              }while(c != END_RSLT_BYTE);
 105   1              //UART_send('\n');
 106   1      }
 107          
 108          /*
 109          #############################################################################
 110                  Serializer related functions
 111          #############################################################################
 112          */
 113          
 114          void serializer_process(OUT_M1* cmd)
 115          {
 116   1              PTS_2DA pts = {1, 0, 0, 0};
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 3   

 117   1              
 118   1              // Si une commande de mvt est demandé
 119   1              if(cmd->Etat_Mouvement == Stopper)
 120   1              {
 121   2                      serializer_state = STOP;
 122   2                      is_processing = 0;
 123   2                      cmd->Etat_Mouvement = Mouvement_non;
 124   2              }
 125   1              else if(cmd->Etat_Mouvement != Mouvement_non)
 126   1              {
 127   2                      // Transition d'état de la FSM
 128   2                      switch(serializer_state)
 129   2                      {
 130   3                              case IDLE:
 131   3                                      idle_next_state(cmd, &pts);
 132   3                                      break;
 133   3                              
 134   3                              case TRANSLATE:
 135   3                                      if(is_processing == 1)
 136   3                                      {
 137   4                                              serializer_state = TRANSLATE;
 138   4                                      }
 139   3                                      else
 140   3                                      {
 141   4                                              serializer_state = STOP;
 142   4                                      }
 143   3                                      break;
 144   3                                      
 145   3                              case ROTATE:
 146   3                                      if(is_processing == 1)
 147   3                                      {
 148   4                                              serializer_state = ROTATE;
 149   4                                      }
 150   3                                      else
 151   3                                      {
 152   4                                              serializer_state = STOP;
 153   4                                      }
 154   3                                      break;
 155   3                                      
 156   3                              case NAVIGATE:
 157   3                                      if(is_processing == 1)
 158   3                                      {
 159   4                                              serializer_state = NAVIGATE;
 160   4                                      }
 161   3                                      else
 162   3                                      {
 163   4                                              serializer_state = STOP;
 164   4                                      }
 165   3                                      break;
 166   3                                      
 167   3                              case STOP:
 168   3                                      serializer_state = IDLE;
 169   3                                      cmd->Etat_Mouvement = Mouvement_non;
 170   3                                      break;
 171   3                              
 172   3                              default:
 173   3                                      serializer_state = STOP;
 174   3                                      break;
 175   3                              
 176   3                      }
 177   2                      
 178   2              }else{
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 4   

 179   2                      serializer_state = IDLE;
 180   2              }
 181   1              
 182   1              serializer_state_machine[serializer_state].state_process(&pts);
 183   1      }
 184          
 185          void idle_next_state(OUT_M1* cmd, PTS_2DA* pts)
 186          {
 187   1              switch(cmd->Etat_Mouvement)
 188   1              {
 189   2                              case Avancer:
 190   2                                      serializer_state = TRANSLATE;
 191   2                                      pts->x = 1;
 192   2                                      pts->speed = cmd->Vitesse;
 193   2                                      break;
 194   2                              
 195   2                              case Reculer:
 196   2                                      serializer_state = TRANSLATE;
 197   2                                      pts->x = -1;
 198   2                                      pts->speed = cmd->Vitesse;
 199   2                                      break;
 200   2                              
 201   2                              case Stopper:
 202   2                                      serializer_state = STOP;
 203   2                                      pts->x = 0;
 204   2                                      pts->speed = 0;
 205   2                                      //serializer_print("mogo 1:0 2:0");
 206   2                                      break;
 207   2      
 208   2                              case Rot_90D:
 209   2                                      serializer_state = ROTATE;
 210   2                                      pts->angle = (-1) * 90;
 211   2                                      pts->speed = 20;
 212   2                                      break;
 213   2                              
 214   2                              case Rot_90G:
 215   2                                      serializer_state = ROTATE;
 216   2                                      pts->angle = 90;
 217   2                                      pts->speed = 20;
 218   2                                      break;
 219   2                              
 220   2                              case Rot_180D:
 221   2                                      serializer_state = ROTATE;
 222   2                                      pts->angle = -180;
 223   2                                      pts->speed = 20;
 224   2                                      break;
 225   2                              
 226   2                              case Rot_180G:
 227   2                                      serializer_state = ROTATE;
 228   2                                      pts->angle = 180;
 229   2                                      pts->speed = 20;
 230   2                                      break;
 231   2      
 232   2                              case Rot_AngD:
 233   2                                      serializer_state = ROTATE;
 234   2                                      pts->angle = -1 * cmd->Angle;
 235   2                                      pts->speed = 20;
 236   2                                      break;
 237   2      
 238   2                              case Rot_AngG:
 239   2                                      serializer_state = ROTATE;
 240   2                                      pts->angle = 1 * cmd->Angle;
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 5   

 241   2                                      pts->speed = 20;
 242   2                                      break;
 243   2                              
 244   2                              default:
 245   2                                      serializer_state = IDLE;
 246   2                                      break;
 247   2                      }
 248   1              
 249   1      }
 250          
 251          void idle(PTS_2DA* pts)
 252          {
 253   1              // Nothing to do
 254   1      }
*** WARNING C280 IN LINE 251 OF src\serializer.c: 'pts': unreferenced local variable
 255          
 256          
 257          void translate(PTS_2DA* pts)
 258          {
 259   1              char speed = 10;
 260   1              
 261   1              if(is_processing == 0)
 262   1              {
 263   2                      if(pts->speed != 0)
 264   2                      {
 265   3                              speed = pts->speed;
 266   3                      }
 267   2                      
 268   2                      setMotors(pts->x * speed, pts->x * speed);
 269   2                      is_processing = 1;
 270   2              }
 271   1              
 272   1      }
 273          
 274          void rotate(PTS_2DA* pts)
 275          {
 276   1              char sens = 0;
 277   1              
 278   1              if(is_processing == 0)
 279   1              {
 280   2                      //clear_encoder();
 281   2                      //getEncoderDistance(LEFT);
 282   2                      moveAngle(pts->angle);
 283   2                      is_processing = 1;
 284   2              }
 285   1              else{
 286   2                      
 287   2                      if(pids_timer >= 5000)
 288   2                      {
 289   3                              is_processing = is_PID_processing();
 290   3                              pids_timer = 0;
 291   3                      }
 292   2                      else{
 293   3                              pids_timer++;
 294   3                      }
 295   2              }
 296   1      }
 297          
 298          void navigate(PTS_2DA* pts)
 299          {
 300   1              static byte navigation_step = 0;
 301   1              int angle = 0;
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 6   

 302   1              
 303   1              switch(navigation_step)
 304   1              {
 305   2                      case 0:
 306   2                              
 307   2                      
 308   2                              break;
 309   2                      
 310   2              }
 311   1              
 312   1              if(is_processing == 0)
 313   1              {
 314   2                      //clear_encoder();
 315   2                      //getEncoderDistance(LEFT);
 316   2                      //moveAngle(pts->angle);
 317   2                      
 318   2                      
 319   2                      is_processing = 1;
 320   2              }
 321   1              else{
 322   2                      
 323   2                      if(pids_timer >= 5000)
 324   2                      {
 325   3                              is_processing = is_PID_processing();
 326   3                              pids_timer = 0;
 327   3                      }
 328   2                      else{
 329   3                              pids_timer++;
 330   3                      }
 331   2              }
 332   1      }
*** WARNING C280 IN LINE 298 OF src\serializer.c: 'pts': unreferenced local variable
 333          
 334          void setMotors(int mtr_speed_1, int mtr_speed_2)
 335          {
 336   1              char cmd[MOGO_CMD_SIZE];
 337   1              
 338   1              sprintf(cmd, "mogo 1:%d 2:%d", mtr_speed_1, mtr_speed_2);
 339   1      
 340   1              serializer_print(cmd);
 341   1              
 342   1              serializer_clear_serial();
 343   1      }
 344          
 345          void moveAngle(int angle)
 346          {
 347   1              char cmd[DIGO_CMD_SIZE];
 348   1              int distance_in_tick = 0, l_dist = 0;
 349   1              
 350   1              distance_in_tick = ANGLE_2_DIST(angle);
 351   1              
 352   1              l_dist = (-1) * distance_in_tick;
 353   1              
 354   1              sprintf(cmd, "digo 1:%d:20 2:%d:20", l_dist, distance_in_tick);
 355   1              serializer_print(cmd);
 356   1              serializer_clear_serial();
 357   1              
 358   1              //memset(cmd, 0, DIGO_CMD_SIZE);
 359   1      }
 360          
 361          void stop(PTS_2DA* pts)
 362          {
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 7   

 363   1              serializer_print("stop");
 364   1              
 365   1              pid_is_processing = 0;
 366   1              
 367   1              serializer_clear_serial();
 368   1              //clear_encoder();
 369   1      }
*** WARNING C280 IN LINE 361 OF src\serializer.c: 'pts': unreferenced local variable
 370          
 371          int getRawEncoders(ENCODER_ID encoder_id)
 372          {
 373   1              int enc_value = 0;
 374   1              char result[ENC_RSLT_SIZE];
 375   1              char c = 0;
 376   1              byte ptr = 0;
 377   1              
 378   1              if(encoder_id == LEFT)
 379   1              {
 380   2                      serializer_print("getenc 1");
 381   2              }
 382   1              else{
 383   2                      serializer_print("getenc 2");
 384   2              }
 385   1              
 386   1              do
 387   1              {
 388   2                      serializer_receive(&c);
 389   2                      result[ptr] = c;
 390   2                      ptr++;
 391   2              }while(c != END_RSLT_BYTE);
 392   1              
 393   1              sscanf(result, "%d", &enc_value);
 394   1              
 395   1              return enc_value;
 396   1      }
 397          
 398          int getEncoderDistance(ENCODER_ID encoder_id)
 399          {
 400   1              int enc_value = 0;
 401   1              
 402   1              enc_value = getRawEncoders(encoder_id);
 403   1              
 404   1              return ENC_2_MM(enc_value);
 405   1      }
 406          
 407          void clear_encoder()
 408          {
 409   1              char result[PID_RSLT_SIZE];
 410   1              char ptr = 0, c = 0;
 411   1              
 412   1              serializer_print("clrenc 1 2");
 413   1      
 414   1              do
 415   1              {
 416   2                      serializer_receive(&c);
 417   2                      result[ptr] = c;
 418   2                      ptr++;
 419   2              }while(c != END_RSLT_BYTE);
 420   1              
 421   1              
 422   1      }
 423          
C51 COMPILER V9.52.0.0   SERIALIZER                                                        03/21/2019 17:13:06 PAGE 8   

 424          char is_PID_processing()
 425          {
 426   1              char result[PID_RSLT_SIZE];
 427   1              int pid_state = 1;
 428   1              char ptr = 0;
 429   1              byte c = 0;
 430   1              
 431   1              serializer_print("pids");
 432   1                      
 433   1              do
 434   1              {
 435   2                      serializer_receive(&c);
 436   2                      if(c != '*')
 437   2                      {
 438   3                              result[ptr] = c;
 439   3                              ptr++;
 440   3                              UART_send(c);
 441   3                      }
 442   2              }while(c != END_RSLT_BYTE);
 443   1              
 444   1              sscanf(result, "%d", &pid_state);
 445   1              
 446   1              memset(result, 0, PID_RSLT_SIZE);
 447   1              
 448   1              return (char)pid_state;
 449   1      }
 450          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2404    ----
   CONSTANT SIZE    =     83    ----
   XDATA SIZE       =     26     178
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
