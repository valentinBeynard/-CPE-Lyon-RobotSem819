C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE SERIALIZER
OBJECT MODULE PLACED IN .\Objects\serializer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\serializer.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\serializer.lst) TABS(2) OBJECT(.\Objects\serializer.obj)

line level    source

   1          #include "serializer.h"
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include "motion.h"
   5          
   6          
   7          const SERIALIZER_FSM_PROCESS serializer_state_machine[6] = {
   8              {IDLE, &idle},
   9              {TRANSLATE, &translate},
  10              {MOVETO, &moveTo},
  11              {ROTATE, &rotate},
  12              {NAVIGATE, &navigate},
  13              {STOP, &stop}
  14          };
  15          
  16          /* Etat courant de la machine d'Etat */
  17          volatile SERIALIZER_STATE serializer_state = IDLE;
  18          
  19          byte is_processing = 0;
  20          
  21          byte is_navigating = 0;
  22          
  23          int pids_timer = 0;
  24          
  25          PTS_2DA robot_position = {0, 0, 0, 0};
  26          
  27          /*
  28          #############################################################################
  29                  UART1 related function for µP 8051F020
  30          #############################################################################
  31          */
  32          
  33          /**
  34            8051 µP :
  35            Initialize devices for commands_parser : UART0 and Timer 2
  36          **/
  37          byte init_serializer_UART1()
  38          {
  39   1        
  40   1        /****** INIT UART1 *****/
  41   1        SCON1 = 0x50;
  42   1        
  43   1        // Réglage timer 4
  44   1        T4CON = 0x3D; // Baud Generator for UART1 + Enable TR4
  45   1        
  46   1        RCAP4L = 0xDC;  // Reload value for BaudRate 19200
  47   1        RCAP4H = 0xFF;
  48   1        
  49   1        return 0;
  50   1      }
  51          
  52          void serializer_receive(byte* read_byte)
  53          {
  54   1        if( (SCON1 & 0x01) == 1)
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 2   

  55   1        {
  56   2          *read_byte = SBUF1;
  57   2          SCON1 &= 0xFE;  // Remise à 0 de RI1
  58   2        }else{
  59   2          *read_byte = '*';
  60   2        }
  61   1      }
  62          
  63          void serializer_send(byte ch)
  64          {
  65   1        SBUF1 = ch;
  66   1        while( (SCON1 & 0x02) == 0){} // Tant que TI1 == 0
  67   1        SCON1 &= 0xFD;  // Remise à 0 de TI1
  68   1      }
  69          
  70          void UART_send(byte ch)
  71          {
  72   1        SBUF0 = ch;
  73   1        while(TI0 == 0){}
  74   1        TI0 = 0;
  75   1      }
  76          
  77          void serializer_print(char* str)
  78          {
  79   1        byte i = 0;
  80   1        for(i = 0 ; i < strlen(str); i++)
  81   1        {
  82   2          //UART_send(*(str+i));
  83   2          serializer_send(*(str+i));
  84   2        }
  85   1        
  86   1        serializer_send(0x0D);
  87   1        //UART_send('\n');
  88   1      }
  89          
  90          void serializer_init_serial()
  91          {
  92   1        char c = 0;
  93   1        do
  94   1        {
  95   2          serializer_receive(&c);
  96   2          //UART_send(c);
  97   2        }while(c != END_RSLT_BYTE);
  98   1        
  99   1      }
 100          
 101          void serializer_clear_serial()
 102          {
 103   1        char c = 0;
 104   1        //UART_send('!');
 105   1        do
 106   1        {
 107   2          serializer_receive(&c);
 108   2          //UART_send(c);
 109   2        }while(c != END_RSLT_BYTE);
 110   1        //UART_send('\n');
 111   1      }
 112          
 113          /*
 114          #############################################################################
 115                  Serializer related functions
 116          #############################################################################
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 3   

 117          */
 118          
 119          //void serializer_process(OUT_M1* cmd)
 120          void serializer_process(PARSER_RESULT* parser)
 121          {
 122   1        PTS_2DA pts = {1, 0, 0, 0};
 123   1        
 124   1        // Si une commande de mvt est demandé
 125   1        if(parser->commands.Etat_Mouvement == Stopper)
 126   1        {
 127   2          serializer_state = STOP;
 128   2          is_processing = 0;
 129   2          parser->commands.Etat_Mouvement = Mouvement_non;
 130   2        }
 131   1        else if(parser->commands.Etat_Mouvement != Mouvement_non)
 132   1        {
 133   2          // Transition d'état de la FSM
 134   2          switch(serializer_state)
 135   2          {
 136   3            case IDLE:
 137   3              idle_next_state(&(parser->commands), &pts);
 138   3              break;
 139   3            
 140   3            case TRANSLATE:
 141   3              if(is_processing == 1)
 142   3              {
 143   4                serializer_state = TRANSLATE;
 144   4              }
 145   3              else
 146   3              {
 147   4                serializer_state = STOP;
 148   4              }
 149   3              break;
 150   3              
 151   3            case ROTATE:
 152   3              // If already rotating
 153   3              if(is_processing == 1)
 154   3              {
 155   4                serializer_state = ROTATE;
 156   4              }
 157   3              else
 158   3              {
 159   4                serializer_state = STOP;
 160   4              }
 161   3              break;
 162   3              
 163   3            case NAVIGATE:
 164   3              if(is_navigating == 1)
 165   3              {
 166   4                serializer_state = NAVIGATE;
 167   4              }
 168   3              else
 169   3              {
 170   4                parser->informations.Etat_BUT_Mouvement = BUT_Atteint_oui;
 171   4                robot_position.angle = 1 * parser->commands.Angle;
 172   4                robot_position.x = parser->commands.Coord_X;
 173   4                robot_position.y = parser->commands.Coord_Y;
 174   4                robot_position.speed = parser->commands.Vitesse;
 175   4                serializer_state = IDLE;
 176   4              }
 177   3              break;
 178   3              
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 4   

 179   3            case MOVETO:
 180   3              if(is_processing == 1)
 181   3              {
 182   4                serializer_state = MOVETO;
 183   4              }
 184   3              else
 185   3              {
 186   4                serializer_state = STOP;
 187   4              }
 188   3              break;
 189   3              
 190   3            case STOP:
 191   3              if(is_navigating == 0)
 192   3              {
 193   4                serializer_state = IDLE;
 194   4                parser->commands.Etat_Mouvement = Mouvement_non;
 195   4              }
 196   3              else{
 197   4                serializer_state = NAVIGATE;
 198   4              }
 199   3              break;
 200   3            
 201   3            default:
 202   3              serializer_state = STOP;
 203   3              break;
 204   3            
 205   3          }
 206   2          
 207   2        }else{
 208   2          serializer_state = IDLE;
 209   2        }
 210   1        
 211   1        serializer_state_machine[serializer_state].state_process(&pts);
 212   1      }
 213          
 214          void idle_next_state(OUT_M1* cmd, PTS_2DA* pts)
 215          {
 216   1        switch(cmd->Etat_Mouvement)
 217   1        {
 218   2            case Avancer:
 219   2              serializer_state = TRANSLATE;
 220   2              pts->x = 1;
 221   2              pts->speed = cmd->Vitesse;
 222   2              break;
 223   2            
 224   2            case Reculer:
 225   2              serializer_state = TRANSLATE;
 226   2              pts->x = -1;
 227   2              pts->speed = cmd->Vitesse;
 228   2              break;
 229   2            
 230   2            case Stopper:
 231   2              serializer_state = STOP;
 232   2              pts->x = 0;
 233   2              pts->speed = 0;
 234   2              //serializer_print("mogo 1:0 2:0");
 235   2              break;
 236   2      
 237   2            case Rot_90D:
 238   2              serializer_state = ROTATE;
 239   2              pts->angle = (-1) * 90;
 240   2              pts->speed = 20;
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 5   

 241   2              break;
 242   2            
 243   2            case Rot_90G:
 244   2              serializer_state = ROTATE;
 245   2              pts->angle = 90;
 246   2              pts->speed = 20;
 247   2              break;
 248   2            
 249   2            case Rot_180D:
 250   2              serializer_state = ROTATE;
 251   2              pts->angle = -180;
 252   2              pts->speed = 20;
 253   2              break;
 254   2            
 255   2            case Rot_180G:
 256   2              serializer_state = ROTATE;
 257   2              pts->angle = 180;
 258   2              pts->speed = 20;
 259   2              break;
 260   2      
 261   2            case Rot_AngD:
 262   2              serializer_state = ROTATE;
 263   2              pts->angle = -1 * cmd->Angle;
 264   2              pts->speed = 20;
 265   2              break;
 266   2      
 267   2            case Rot_AngG:
 268   2              serializer_state = ROTATE;
 269   2              pts->angle = 1 * cmd->Angle;
 270   2              pts->speed = 20;
 271   2              break;
 272   2            
 273   2            case Depl_Coord:
 274   2              serializer_state = NAVIGATE;
 275   2              pts->angle = 1 * cmd->Angle;
 276   2              pts->x = cmd->Coord_X;
 277   2              pts->y = cmd->Coord_Y;
 278   2              pts->speed = cmd->Vitesse;
 279   2              break;
 280   2            
 281   2            default:
 282   2              serializer_state = IDLE;
 283   2              break;
 284   2          }
 285   1        
 286   1      }
 287          
 288          void idle(PTS_2DA* pts)
 289          {
 290   1        // Nothing to do
 291   1      }
*** WARNING C280 IN LINE 288 OF src\serializer.c: 'pts': unreferenced local variable
 292          
 293          
 294          void translate(PTS_2DA* pts)
 295          {
 296   1        char speed = 10;
 297   1        
 298   1        if(is_processing == 0)
 299   1        {
 300   2          if(pts->speed != 0)
 301   2          {
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 6   

 302   3            speed = pts->speed;
 303   3          }
 304   2        
 305   2          setMotors(pts->x * speed, pts->x * speed);
 306   2          is_processing = 1;
 307   2        }
 308   1        
 309   1      }
 310          
 311          void rotate(PTS_2DA* pts)
 312          {
 313   1        char sens = 0;
 314   1        
 315   1        if(is_processing == 0)
 316   1        {
 317   2          //clear_encoder();
 318   2          //getEncoderDistance(LEFT);
 319   2          moveAngle(pts->angle);
 320   2          is_processing = 1;
 321   2        }
 322   1        else{
 323   2          
 324   2          if(pids_timer >= 5000)
 325   2          {
 326   3            is_processing = is_PID_processing();
 327   3            pids_timer = 0;
 328   3          }
 329   2          else{
 330   3            pids_timer++;
 331   3          }
 332   2        }
 333   1      }
 334          
 335          void navigate(PTS_2DA* pts)
 336          {
 337   1        static byte navigation_step = 0;
 338   1        PTS_2DA temp_pts = {0, 0, 0, 0};
 339   1        
 340   1        switch(navigation_step)
 341   1        {
 342   2          case 0:
 343   2            // Start Navigation Flag
 344   2            is_navigating = 1;
 345   2            temp_pts.angle = delta_angle(&(pts->angle), &(robot_position.angle) );
 346   2            serializer_state = ROTATE;
 347   2            navigation_step++;
 348   2            rotate(&temp_pts);
 349   2            break;
 350   2          
 351   2          case 1:
 352   2            temp_pts.x = (robot_position.x - pts->x);
 353   2            temp_pts.y = (robot_position.y - pts->y);
 354   2            temp_pts.speed = pts->speed;
 355   2            serializer_state = MOVETO;
 356   2            navigation_step++;
 357   2            moveTo(&temp_pts);
 358   2            break;
 359   2          
 360   2          case 2:
 361   2            temp_pts.angle = delta_angle(&(pts->angle), &(robot_position.angle) );
 362   2            serializer_state = ROTATE;
 363   2            navigation_step++;
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 7   

 364   2            rotate(&temp_pts);
 365   2            break;
 366   2          
 367   2          case 3:
 368   2            is_navigating = 0;
 369   2            navigation_step = 0;
 370   2            break;
 371   2          
 372   2        }
 373   1        
 374   1        
 375   1      }
 376          
 377          void setMotors(int mtr_speed_1, int mtr_speed_2)
 378          {
 379   1        char cmd[MOGO_CMD_SIZE];
 380   1        
 381   1        sprintf(cmd, "mogo 1:%d 2:%d", mtr_speed_1, mtr_speed_2);
 382   1      
 383   1        serializer_print(cmd);
 384   1        
 385   1        serializer_clear_serial();
 386   1      }
 387          
 388          void moveTo(PTS_2DA* pts)
 389          {
 390   1        char cmd[DIGO_CMD_SIZE];
 391   1        int distance_in_tick = 0;
 392   1        
 393   1        if(is_processing == 0)
 394   1        {
 395   2          distance_in_tick = distance(pts->x, pts->y);
 396   2          
 397   2          // TODO : Pour le moment, la vitesse du digo est de 28%, donc pas la valeur set par TV
 398   2          // On est obligé car ce 28 est fixé par le DPID et le VPID du sérializer ...
 399   2          sprintf(cmd, "digo 1:%d:28 2:%d:28", distance_in_tick, distance_in_tick);
 400   2        
 401   2          serializer_print(cmd);
 402   2          serializer_clear_serial();
 403   2          
 404   2          is_processing = 1;
 405   2        }
 406   1        else{
 407   2          
 408   2          if(pids_timer >= 5000)
 409   2          {
 410   3            is_processing = is_PID_processing();
 411   3            pids_timer = 0;
 412   3          }
 413   2          else{
 414   3            pids_timer++;
 415   3          }
 416   2        }
 417   1      }
 418          
 419          void moveAngle(int angle)
 420          {
 421   1        char cmd[DIGO_CMD_SIZE];
 422   1        int distance_in_tick = 0, l_dist = 0;
 423   1        
 424   1        distance_in_tick = ANGLE_2_DIST(angle);
 425   1        
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 8   

 426   1        l_dist = (-1) * distance_in_tick;
 427   1        
 428   1        sprintf(cmd, "digo 1:%d:20 2:%d:20", l_dist, distance_in_tick);
 429   1        serializer_print(cmd);
 430   1        serializer_clear_serial();
 431   1        
 432   1        //memset(cmd, 0, DIGO_CMD_SIZE);
 433   1      }
 434          
 435          void stop(PTS_2DA* pts)
 436          {
 437   1        serializer_print("stop"); 
 438   1        serializer_clear_serial();
 439   1        //clear_encoder();
 440   1      }
*** WARNING C280 IN LINE 435 OF src\serializer.c: 'pts': unreferenced local variable
 441          
 442          int getRawEncoders(ENCODER_ID encoder_id)
 443          {
 444   1        int enc_value = 0;
 445   1        char result[ENC_RSLT_SIZE];
 446   1        char c = 0;
 447   1        byte ptr = 0;
 448   1        
 449   1        if(encoder_id == LEFT)
 450   1        {
 451   2          serializer_print("getenc 1");
 452   2        }
 453   1        else{
 454   2          serializer_print("getenc 2");
 455   2        }
 456   1        
 457   1        do
 458   1        {
 459   2          serializer_receive(&c);
 460   2          result[ptr] = c;
 461   2          ptr++;
 462   2        }while(c != END_RSLT_BYTE);
 463   1        
 464   1        sscanf(result, "%d", &enc_value);
 465   1        
 466   1        return enc_value;
 467   1      }
 468          
 469          int getEncoderDistance(ENCODER_ID encoder_id)
 470          {
 471   1        int enc_value = 0;
 472   1        
 473   1        enc_value = getRawEncoders(encoder_id);
 474   1        
 475   1        return ENC_2_MM(enc_value);
 476   1      }
 477          
 478          void clear_encoder()
 479          {
 480   1        char result[PID_RSLT_SIZE];
 481   1        char ptr = 0, c = 0;
 482   1        
 483   1        serializer_print("clrenc 1 2");
 484   1      
 485   1        do
 486   1        {
C51 COMPILER V9.55   SERIALIZER                                                            03/26/2019 23:20:41 PAGE 9   

 487   2          serializer_receive(&c);
 488   2          result[ptr] = c;
 489   2          ptr++;
 490   2        }while(c != END_RSLT_BYTE);
 491   1        
 492   1        
 493   1      }
 494          
 495          char is_PID_processing()
 496          {
 497   1        char result[PID_RSLT_SIZE];
 498   1        int pid_state = 1;
 499   1        char ptr = 0;
 500   1        byte c = 0;
 501   1        
 502   1        serializer_print("pids");
 503   1          
 504   1        do
 505   1        {
 506   2          serializer_receive(&c);
 507   2          if(c != '*')
 508   2          {
 509   3            result[ptr] = c;
 510   3            ptr++;
 511   3            UART_send(c);
 512   3          }
 513   2        }while(c != END_RSLT_BYTE);
 514   1        
 515   1        sscanf(result, "%d", &pid_state);
 516   1        
 517   1        memset(result, 0, PID_RSLT_SIZE);
 518   1        
 519   1        return (char)pid_state;
 520   1      }
 521          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3237    ----
   CONSTANT SIZE    =    109    ----
   XDATA SIZE       =     35     226
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
