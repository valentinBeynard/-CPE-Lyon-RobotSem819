C51 COMPILER V9.55   LIGHT_BEAM                                                            04/23/2019 12:03:30 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE LIGHT_BEAM
OBJECT MODULE PLACED IN light_beam.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\light_beam.c LARGE OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\light_beam.lst) TABS(2) OBJECT(light_beam.obj)

line level    source

   1          #include "light_beam.h"
   2          
   3          //port de sortie
   4          sbit PWN_pin = P1^2;
   5          sbit FLASH_pin = P1^0;
   6          
   7          volatile int servo_angle_V = 0;
   8          
   9          int duree_flash = 10;
  10          int duree_no_flash = 10;
  11          byte nbr_flash = 10;
  12          byte pwn_duty = 10;
  13          
  14          int prescaler_counter = -1;
  15          LIGHT_STATE light = LIGHT_ON;
  16          LIGHT_GENERATOR light_genrator_state = STOP;
  17          
  18          
  19          /*
  20          #############################################################################
  21                  Interrupt Routine For Timer 0
  22          #############################################################################
  23          */
  24          
  25          
  26          void timer_0_int() interrupt 1
  27          { 
  28   1        static int nbr_interrupt = 0;
  29   1        static char high = 0;
  30   1        
  31   1        int duree_imp = 0;
  32   1        int reload_value = 0;
  33   1        
  34   1        duree_imp = 13 * servo_angle_V + 2768;// (cf excel table 3)
  35   1        
  36   1        //duree_imp = 13*(servo_angle_V+90) + 1800 ;// 900us pour 90°  (cf doc technique)
  37   1        
  38   1        //duree_imp = SERVO_PWN_ANGLE_COEF *(servo_angle_V+90) + 2000 ;// 1ms pour -90°  (cf doc technique)
  39   1      
  40   1        PWN_pin = !PWN_pin;
  41   1        
  42   1        if (high == 1)
  43   1        {
  44   2          reload_value = 0xFFFF - (36666 - duree_imp );
  45   2          high=0;
  46   2        } else {
  47   2          
  48   2          reload_value = 0xFFFF - duree_imp;
  49   2          high=1;
  50   2        }
  51   1        TL0= reload_value;
  52   1        TH0= reload_value >> 8; //on décale pour obtenir les bits de poids fort
  53   1        
  54   1        
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/23/2019 12:03:30 PAGE 2   

  55   1        if(nbr_interrupt >= 500)
  56   1        {
  57   2          ET0 = 0;  // Diseable timer0 interuption
  58   2          PWN_pin = 0;
  59   2          high = 0;
  60   2          nbr_interrupt = 0;
  61   2        }
  62   1        else
  63   1        {
  64   2          nbr_interrupt++;
  65   2        }
  66   1      }
  67          
  68          /*
  69          #############################################################################
  70                  End of Interrupt Routine For Timer 0
  71          #############################################################################
  72          */
  73          
  74          /*
  75          #############################################################################
  76                  Interrupt Routine For Timer 1
  77          #############################################################################
  78          */
  79          
  80          void timer_1_int() interrupt 3
  81          { 
  82   1        static char high = 1;
  83   1        
  84   1        int reload_value = 0;
  85   1        
  86   1        if (high == 1)
  87   1        {
  88   2          reload_value = 0xFFFF - (LIGHT_PWN_PERIOD - pwn_duty * LIGHT_PWN_DUTY_1 );
  89   2          FLASH_pin = 0;
  90   2          high=0;
  91   2        }
  92   1        else
  93   1        {
  94   2          reload_value = 0xFFFF - pwn_duty * LIGHT_PWN_DUTY_1;
  95   2          prescaler_counter++;
  96   2          ( FLASH_pin = (light == LIGHT_ON) ? 1 : 0);
  97   2          high=1;
  98   2        }
  99   1        
 100   1        
 101   1        TL1= reload_value;
 102   1        TH1= reload_value >> 8; //on décale pour obtenir les bits de poids fort
 103   1        
 104   1        light_beam_flash_sequence();
 105   1        
 106   1        if(light_genrator_state == FINISH)
 107   1        {
 108   2          ET1 = 0;
 109   2          high = 0;
 110   2        }
 111   1      }
 112          
 113          void light_beam_flash_sequence()
 114          {
 115   1        static byte nbr_seq = 0;
 116   1      
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/23/2019 12:03:30 PAGE 3   

 117   1        
 118   1        if(light == LIGHT_ON)
 119   1        {
 120   2          if(prescaler_counter >= 10 * duree_flash)
 121   2          {
 122   3            prescaler_counter = 0;
 123   3            light = LIGHT_OFF;
 124   3          }
 125   2        }
 126   1        else
 127   1        {
 128   2          if(prescaler_counter >= 10 * duree_no_flash)
 129   2          {
 130   3            light = LIGHT_ON;
 131   3            prescaler_counter = 0;
 132   3            nbr_seq++;
 133   3            if(nbr_seq >= nbr_flash)
 134   3            {
 135   4              nbr_seq = 0;
 136   4              light_genrator_state = FINISH;
 137   4            }
 138   3          }
 139   2        }
 140   1        
 141   1      }
 142          /*
 143          #############################################################################
 144                  End of Interrupt Routine For Timer 1
 145          #############################################################################
 146          */
 147          
 148          /*
 149          #############################################################################
 150                  Peripheric initialize
 151          #############################################################################
 152          */
 153          
 154          
 155          void Init_light_beam()
 156          {
 157   1        
 158   1        // Push-Pull mode for P0.0 and P0.1
 159   1        P1MDOUT |= 0x0F;
 160   1        PWN_pin = 0;
 161   1        FLASH_pin = 0;
 162   1        
 163   1        lb_init_timer0();
 164   1        
 165   1        lb_init_timer1();
 166   1        
 167   1        ET0 = 0;  // Diseable timer0 interuption
 168   1        ET1 = 0;  // Diseable timer1 interuption
 169   1      
 170   1      }
 171          
 172          
 173          void lb_init_timer0()
 174          { 
 175   1        //Reglages Timer 0 (a SYSCLK/12 selon CKCON, soit un incrément tous les 0.545us)
 176   1        TMOD |=0x01; //mode 1
 177   1        TCON |= 0x11; // Enable Timer0 (bit4) and enable interupt on edge (bit0)
 178   1        TL0=0xA8;
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/23/2019 12:03:30 PAGE 4   

 179   1        TH0=0xFB;
 180   1        
 181   1      }
 182          
 183          void lb_init_timer1()
 184          { 
 185   1        int init_reload_value = 0;
 186   1        
 187   1        //Reglages Timer 0 (a SYSCLK/12 selon CKCON, soit un incrément tous les 0.545us)
 188   1        TMOD |= 0x10; // Timer 1 Mode 1
 189   1        TCON |= 0x44; // Enable Timer1 (bit6) and enable interupt on edge (bit2)
 190   1        
 191   1        init_reload_value = 0xFFFF - pwn_duty * LIGHT_PWN_DUTY_1;
 192   1        
 193   1        TL1= init_reload_value;
 194   1        TH1= init_reload_value >> 8;
 195   1        
 196   1      }
 197          
 198          
 199          /*
 200          #############################################################################
 201                  Light Beam Emetter Core
 202          #############################################################################
 203          */
 204          
 205          void light_beam_process(OUT_M2 * cmd)
 206          {
 207   1        
 208   1        
 209   1        if(cmd->Etat_Servo == Servo_oui)
 210   1        {
 211   2          light_beam_move(cmd);
 212   2        }
 213   1        
 214   1        if(cmd->Etat_Lumiere == Allumer)
 215   1        {
 216   2          switch(light_genrator_state)
 217   2          {
 218   3            case STOP:
 219   3              light_beam_switch_ON(cmd);
 220   3              break;
 221   3            case FINISH:
 222   3              cmd->Etat_Lumiere = Lumiere_non;
 223   3              break;
 224   3            default:
 225   3              break;    
 226   3          } 
 227   2        }
 228   1        else if(cmd->Etat_Lumiere == Eteindre)
 229   1        {
 230   2          // TODO
 231   2        }
 232   1        
 233   1      }
 234          
 235          void light_beam_move(OUT_M2 * cmd)
 236          {
 237   1        // Set angle
 238   1        lb_set_angle(cmd->Servo_Angle);
 239   1        
 240   1        // Re-launch PWN
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/23/2019 12:03:30 PAGE 5   

 241   1        //pwn_over = 0;
 242   1        ET0 = 1;
 243   1        
 244   1        // Clear CMD Flag
 245   1        cmd->Etat_Servo = Servo_non;
 246   1        
 247   1        LED = 1;
 248   1        
 249   1      }
 250          
 251          void light_beam_switch_ON(OUT_M2 * cmd)
 252          {
 253   1        pwn_duty = cmd->Lumiere_Intensite;
 254   1        duree_flash = cmd->Lumiere_Duree;
 255   1        duree_no_flash = cmd->Lumire_Extinction;
 256   1        nbr_flash = cmd->Lumiere_Nbre;
 257   1        
 258   1        light_genrator_state = GENERATE;
 259   1        
 260   1        FLASH_pin = 1;
 261   1        
 262   1        // Re-launch PWN
 263   1        ET1 = 1;
 264   1        
 265   1        LED = 1;
 266   1      
 267   1      }
 268          
 269          
 270          
 271          void lb_set_angle(int angle)
 272          {
 273   1        servo_angle_V = angle;
 274   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1084    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     36    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
