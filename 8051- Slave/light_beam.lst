C51 COMPILER V9.55   LIGHT_BEAM                                                            04/18/2019 17:00:09 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE LIGHT_BEAM
OBJECT MODULE PLACED IN light_beam.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\light_beam.c LARGE OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\light_beam.lst) TABS(2) OBJECT(light_beam.obj)

line level    source

   1          #include "light_beam.h"
   2          
   3          //port de sortie
   4          sbit PWN_pin = P1^0;
   5          sbit FLASH_pin = P1^1;
   6          
   7          volatile int servo_angle_V = -90;
   8          
   9          int duree_flash = 10;
  10          int duree_no_flash = 10;
  11          byte nbr_flash = 10;
  12          byte pwn_duty = 10;
  13          
  14          int prescaler_counter = -1;
  15          LIGHT_STATE light = LIGHT_ON;
  16          LIGHT_GENERATOR light_genrator_state = STOP;
  17          
  18          
  19          /*
  20          #############################################################################
  21                  Interrupt Routine For Timer 0
  22          #############################################################################
  23          */
  24          
  25          
  26          void timer_0_int() interrupt 1
  27          { 
  28   1        static byte nbr_interrupt = 0;
  29   1        static char high = 0;
  30   1        
  31   1        int duree_imp = 0;
  32   1        int reload_value = 0;
  33   1      
  34   1        //duree_imp = 10*(servo_angle_V+90) + 600 ;// 600us pour 90°  (cf doc technique)
  35   1        
  36   1        duree_imp = SERVO_PWN_ANGLE_COEF *(servo_angle_V+90) + 2000 ;// 1ms pour -90°  (cf doc technique)
  37   1      
  38   1        PWN_pin = !PWN_pin;
  39   1        
  40   1        if (high == 1)
  41   1        {
  42   2          reload_value = 0xFFFF - (2 * SERVO_PWN_PERIOD - duree_imp );
  43   2          high=0;
  44   2        } else {
  45   2          
  46   2          reload_value = 0xFFFF - duree_imp;
  47   2          high=1;
  48   2        }
  49   1        TL0= reload_value;
  50   1        TH0= reload_value >> 8; //on décale pour obtenir les bits de poids fort
  51   1        
  52   1        
  53   1        if(nbr_interrupt >= 150)
  54   1        {
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/18/2019 17:00:09 PAGE 2   

  55   2          ET0 = 0;  // Diseable timer0 interuption
  56   2          PWN_pin = 0;
  57   2          high = 0;
  58   2          nbr_interrupt = 0;
  59   2        }
  60   1        else
  61   1        {
  62   2          nbr_interrupt++;
  63   2        }
  64   1      }
  65          
  66          /*
  67          #############################################################################
  68                  End of Interrupt Routine For Timer 0
  69          #############################################################################
  70          */
  71          
  72          /*
  73          #############################################################################
  74                  Interrupt Routine For Timer 1
  75          #############################################################################
  76          */
  77          
  78          void timer_1_int() interrupt 3
  79          { 
  80   1        static char high = 1;
  81   1        
  82   1        int reload_value = 0;
  83   1        
  84   1        if (high == 1)
  85   1        {
  86   2          reload_value = 0xFFFF - (LIGHT_PWN_PERIOD - pwn_duty * LIGHT_PWN_DUTY_1 );
  87   2          FLASH_pin = 0;
  88   2          high=0;
  89   2        }
  90   1        else
  91   1        {
  92   2          reload_value = 0xFFFF - pwn_duty * LIGHT_PWN_DUTY_1;
  93   2          prescaler_counter++;
  94   2          ( FLASH_pin = (light == LIGHT_ON) ? 1 : 0);
  95   2          high=1;
  96   2        }
  97   1        
  98   1        
  99   1        TL1= reload_value;
 100   1        TH1= reload_value >> 8; //on décale pour obtenir les bits de poids fort
 101   1        
 102   1        light_beam_flash_sequence();
 103   1        
 104   1        if(light_genrator_state == FINISH)
 105   1        {
 106   2          ET1 = 0;
 107   2          high = 0;
 108   2        }
 109   1      }
 110          
 111          void light_beam_flash_sequence()
 112          {
 113   1        static byte nbr_seq = 0;
 114   1      
 115   1        
 116   1        if(light == LIGHT_ON)
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/18/2019 17:00:09 PAGE 3   

 117   1        {
 118   2          if(prescaler_counter >= 10 * duree_flash)
 119   2          {
 120   3            prescaler_counter = 0;
 121   3            light = LIGHT_OFF;
 122   3          }
 123   2        }
 124   1        else
 125   1        {
 126   2          if(prescaler_counter >= 10 * duree_no_flash)
 127   2          {
 128   3            light = LIGHT_ON;
 129   3            prescaler_counter = 0;
 130   3            nbr_seq++;
 131   3            if(nbr_seq >= nbr_flash)
 132   3            {
 133   4              nbr_seq = 0;
 134   4              light_genrator_state = FINISH;
 135   4            }
 136   3          }
 137   2        }
 138   1        
 139   1      }
 140          /*
 141          #############################################################################
 142                  End of Interrupt Routine For Timer 1
 143          #############################################################################
 144          */
 145          
 146          /*
 147          #############################################################################
 148                  Peripheric initialize
 149          #############################################################################
 150          */
 151          
 152          
 153          void Init_light_beam()
 154          {
 155   1        
 156   1        // Push-Pull mode for P0.0 and P0.1
 157   1        P1MDOUT |= 0x03;
 158   1        PWN_pin = 0;
 159   1        FLASH_pin = 0;
 160   1        
 161   1        lb_init_timer0();
 162   1        
 163   1        lb_init_timer1();
 164   1        
 165   1        ET0 = 0;  // Diseable timer0 interuption
 166   1        ET1 = 0;  // Diseable timer1 interuption
 167   1      
 168   1      }
 169          
 170          
 171          void lb_init_timer0()
 172          { 
 173   1        //Reglages Timer 0 (a SYSCLK/12 selon CKCON, soit un incrément tous les 0.545us)
 174   1        TMOD |=0x01; //mode 1
 175   1        TCON |= 0x11; // Enable Timer0 (bit4) and enable interupt on edge (bit0)
 176   1        TL0=0xA8;
 177   1        TH0=0xFB;
 178   1        
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/18/2019 17:00:09 PAGE 4   

 179   1      }
 180          
 181          void lb_init_timer1()
 182          { 
 183   1        int init_reload_value = 0;
 184   1        
 185   1        //Reglages Timer 0 (a SYSCLK/12 selon CKCON, soit un incrément tous les 0.545us)
 186   1        TMOD |= 0x10; // Timer 1 Mode 1
 187   1        TCON |= 0x44; // Enable Timer1 (bit6) and enable interupt on edge (bit2)
 188   1        
 189   1        init_reload_value = 0xFFFF - pwn_duty * LIGHT_PWN_DUTY_1;
 190   1        
 191   1        TL1= init_reload_value;
 192   1        TH1= init_reload_value >> 8;
 193   1        
 194   1      }
 195          
 196          
 197          /*
 198          #############################################################################
 199                  Light Beam Emetter Core
 200          #############################################################################
 201          */
 202          
 203          void light_beam_process(OUT_M2 * cmd)
 204          {
 205   1        
 206   1        
 207   1        if(cmd->Etat_Servo == Servo_oui)
 208   1        {
 209   2          light_beam_move(cmd);
 210   2        }
 211   1      
 212   1        if(cmd->Etat_Lumiere == Allumer)
 213   1        {
 214   2          switch(light_genrator_state)
 215   2          {
 216   3            case STOP:
 217   3              light_beam_switch_ON(cmd);
 218   3              break;
 219   3            case FINISH:
 220   3              cmd->Etat_Lumiere = Lumiere_non;
 221   3              break;
 222   3            default:
 223   3              break;    
 224   3          } 
 225   2        }
 226   1        else if(cmd->Etat_Lumiere == Eteindre)
 227   1        {
 228   2          // TODO
 229   2        }
 230   1        
 231   1      }
 232          
 233          void light_beam_move(OUT_M2 * cmd)
 234          {
 235   1        // Set angle
 236   1        if(cmd->Servo_Angle != 0)
 237   1        {
 238   2          lb_set_angle(cmd->Servo_Angle);
 239   2        }
 240   1        else
C51 COMPILER V9.55   LIGHT_BEAM                                                            04/18/2019 17:00:09 PAGE 5   

 241   1        {
 242   2          cmd->Servo_Angle = 90;
 243   2          lb_set_angle(cmd->Servo_Angle);
 244   2        }
 245   1        
 246   1        // Re-launch PWN
 247   1        //pwn_over = 0;
 248   1        ET0 = 1;
 249   1        
 250   1        // Clear CMD Flag
 251   1        cmd->Etat_Servo = Servo_non;
 252   1        
 253   1        LED = 1;
 254   1        
 255   1      }
 256          
 257          void light_beam_switch_ON(OUT_M2 * cmd)
 258          {
 259   1        pwn_duty = cmd->Lumiere_Intensite;
 260   1        duree_flash = cmd->Lumiere_Duree;
 261   1        duree_no_flash = cmd->Lumire_Extinction;
 262   1        nbr_flash = cmd->Lumiere_Nbre;
 263   1        
 264   1        light_genrator_state = GENERATE;
 265   1        
 266   1        FLASH_pin = 1;
 267   1        
 268   1        // Re-launch PWN
 269   1        ET1 = 1;
 270   1        
 271   1        LED = 1;
 272   1      
 273   1      }
 274          
 275          
 276          
 277          void lb_set_angle(int angle)
 278          {
 279   1        servo_angle_V = angle;
 280   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1142    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     35    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
