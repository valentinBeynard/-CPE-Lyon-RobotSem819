C51 COMPILER V9.55   SPI_MASTER                                                            04/10/2019 12:14:28 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE SPI_MASTER
OBJECT MODULE PLACED IN .\Objects\spi_master.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\spi_master.c LARGE OPTIMIZE(1,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\spi_master.lst) TABS(2) OBJECT(.\Objects\spi_master.obj)

line level    source

   1          //------------------------------------------------------------------------------------
   2          // master.c
   3          //------------------------------------------------------------------------------------
   4          // DATE: 20/03/2019
   5          //
   6          // Target: C8051F02x
   7          // Tool chain: KEIL Microvision 4
   8          //
   9          //------------------------------------------------------------------------------------
  10          #include "c8051F020.h"
  11          #include "spi_master.h"
  12          #include <stdlib.h>
  13          #include <string.h>
  14          
  15          /*
  16              FULL STATE MACHINE
  17          
  18              Liste des Etats de la machines d'état de la SPI associés à leur fonction
  19          */
  20          const SPI_FSM_PROCESS spi_state_machine[4] = {
  21              {SPI_IDLE, &spi_idle},
  22              {SPI_TXRX, &spi_txrx},
  23              {SPI_GET_DATA, &spi_get_data},
  24              {SPI_SET_DATA, &spi_set_data}
  25          };
  26          
  27          SPI_STATE spi_state = SPI_IDLE;
  28          
  29          sbit slave_selector = P1^0;
  30          
  31          byte spi_data_in[TRAM_SIZE];
  32          byte spi_data_in_ptr = 0;
  33          
  34          byte spi_data_out[TRAM_SIZE];
  35          byte spi_data_out_ptr = 0;
  36          
  37          
  38          /*
  39          #############################################################################
  40                  Interrupt Routine
  41          #############################################################################
  42          */
  43          
  44          //On remet à zero le bit d'interruption qui est mis a 1 a chaque fin de transfert de donnees
  45          void spi_int() interrupt 6
  46          {
  47   1        // Reset Transmission Flag
  48   1        SPIF = 0;
  49   1        
  50   1        // Read data 
  51   1        spi_data_in[spi_data_in_ptr] = SPI0DAT;
  52   1        
  53   1        spi_data_in_ptr++;
  54   1        
C51 COMPILER V9.55   SPI_MASTER                                                            04/10/2019 12:14:28 PAGE 2   

  55   1      }
  56          
  57          /*
  58          #############################################################################
  59                  Peripheric initialize
  60          #############################################################################
  61          */
  62          
  63          void Init_SPI() 
  64          {
  65   1        
  66   1        //Interruptions
  67   1        //EIE1 |= 0x01;
  68   1        
  69   1        // Active Crossbar
  70   1        XBR0 |= 0x02;  //Route les 4 ports de la SPI et les 2 de l'UART0;
  71   1        
  72   1        
  73   1        // Activation des ports 
  74   1        P0MDOUT |= 0xFF;
  75   1        P0MDOUT &= 0xFD;
  76   1        P1MDOUT |= 0xFF;
  77   1        
  78   1        SPI0CFG = 0x87;//Configure CLK SPI (actif front montant) + transmission des 8 bits
  79   1        SPI0CN |= 0x02; //active mode master
  80   1        SPI0CKR = 0x48; //On definit la fréquence SCK a 150kHz (elle doit etre comprise entre 100 et 200kHz pour 
             -une bonne optimisation)
  81   1        
  82   1        slave_selector = 0;
  83   1        
  84   1        SPI0CN |= 0x01; //active la SPI
  85   1      }
  86          
  87          /*
  88          #############################################################################
  89                  Pour µP 8051F020
  90          #############################################################################
  91          */
  92          
  93          void spi_send_char(char a){
  94   1          slave_selector = SLAVE_ENABLE;
  95   1          
  96   1          SPI0DAT = a;
  97   1          // Wait until the end of transmission
  98   1          while(TXBSY == 1) {}
  99   1          
 100   1          
 101   1          slave_selector = SLAVE_DISEABLE;
 102   1      }
 103          
 104          void spi_receive_char(byte* read_byte)
 105          {
 106   1        if(WCOL == 1)
 107   1        {
 108   2          *read_byte = SPI0DAT;
 109   2          WCOL = 0;
 110   2        }else{
 111   2          *read_byte = 0;
 112   2        }
 113   1      }
 114          
 115          
C51 COMPILER V9.55   SPI_MASTER                                                            04/10/2019 12:14:28 PAGE 3   

 116          void spi_process(SPI_PACKET* spi_packet)
 117          {
 118   1        spi_state_machine[spi_state].state_process(spi_packet);
 119   1      }
 120          
 121          void spi_idle(SPI_PACKET* spi_packet)
 122          {
 123   1        // Si interrupt deseable
 124   1        if( (EIE1 & 0x01) != 1 )
 125   1        {   
 126   2          if(spi_packet->commands->Etat_ACQ_Son == ACQ_oui
 127   2            || spi_packet->commands->Etat_Lumiere != Lumiere_non
 128   2            || spi_packet->commands->Etat_Servo == Servo_V
 129   2            || spi_packet->commands->Etat_Photo != Photo_non)
 130   2          {
 131   3            spi_state = SPI_SET_DATA;
 132   3          }
 133   2        }
 134   1      }
 135          
 136          void spi_txrx(SPI_PACKET* spi_packet)
 137          {
 138   1        spi_send_char('B');
 139   1        /*
 140   1        if(spi_data_out_ptr < TRAM_SIZE)
 141   1        {
 142   1          spi_send_char(spi_data_out[spi_data_out_ptr]);
 143   1          spi_data_out_ptr++;
 144   1        }
 145   1        else
 146   1        {
 147   1          // DISEABLE INTERRUPT
 148   1          EIE1 &= 0xFE;
 149   1          spi_state = SPI_GET_DATA;
 150   1        }*/
 151   1        
 152   1      }
*** WARNING C280 IN LINE 136 OF src\spi_master.c: 'spi_packet': unreferenced local variable
 153          
 154          
 155          void spi_get_data(SPI_PACKET* spi_packet)
 156          {
 157   1        //*(spi_packet->spi_data) = spi_data_in;
 158   1        spi_packet->ready = 1;
 159   1      
 160   1        memset(spi_data_in, 0, spi_data_in_ptr);
 161   1        memset(spi_data_out, 0, spi_data_out_ptr);
 162   1        spi_data_in_ptr = 0;
 163   1        spi_data_out_ptr = 0;
 164   1        
 165   1        spi_state = SPI_IDLE;
 166   1      }
 167          
 168          void spi_set_data(SPI_PACKET* spi_packet)
 169          {
 170   1        // TODO 
 171   1        spi_data_out[0] = SPI_START_BYTE;
 172   1        spi_data_out[1] = 0xA1;
 173   1        spi_data_out[2] = 0xA2;
 174   1        spi_data_out[3] = 0xA3;
 175   1        spi_data_out[4] = 0xA4;
 176   1        spi_data_out[5] = 0xA5;
C51 COMPILER V9.55   SPI_MASTER                                                            04/10/2019 12:14:28 PAGE 4   

 177   1        spi_data_out[6] = 0xA6;
 178   1        spi_data_out[7] = 0xA7;
 179   1        spi_data_out[8] = 0xA8;
 180   1        spi_data_out[9] = SPI_STOP_BYTE;
 181   1        
 182   1        // Enable Interrupt
 183   1        EIE1 |= 0x01;
 184   1        spi_state = SPI_TXRX;
 185   1      
 186   1      }
*** WARNING C280 IN LINE 168 OF src\spi_master.c: 'spi_packet': unreferenced local variable
 187          
 188          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    533    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     58    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
