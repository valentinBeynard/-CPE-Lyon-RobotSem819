C51 COMPILER V9.55   SPI_MASTER                                                            05/23/2019 16:49:15 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE SPI_MASTER
OBJECT MODULE PLACED IN .\Objects\spi_master.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\spi_master.c LARGE OPTIMIZE(1,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\spi_master.lst) TABS(2) OBJECT(.\Objects\spi_master.obj)

line level    source

   1          //------------------------------------------------------------------------------------
   2          // master.c
   3          //------------------------------------------------------------------------------------
   4          // DATE: 20/03/2019
   5          //
   6          // Target: C8051F02x
   7          // Tool chain: KEIL Microvision 4
   8          //
   9          //------------------------------------------------------------------------------------
  10          #include "c8051F020.h"
  11          #include "spi_master.h"
  12          #include <stdlib.h>
  13          #include <string.h>
  14          
  15          
  16          sbit slave_selector = P1^0;
  17          
  18          byte spi_data_in[TRAM_SIZE];
  19          byte spi_data_in_ptr = 0;
  20          
  21          byte spi_data_out[TRAM_SIZE];
  22          
  23          /*
  24          #############################################################################
  25                  Interrupt Routine
  26          #############################################################################
  27          */
  28          
  29          //On remet à zero le bit d'interruption qui est mis a 1 a chaque fin de transfert de donnees
  30          void spi_int() interrupt 6
  31          {
  32   1        // Reset Transmission Flag
  33   1        SPIF = 0;
  34   1        
  35   1        // Read 
  36   1        spi_data_in[spi_data_in_ptr] = SPI0DAT;
  37   1        
  38   1        spi_data_in_ptr++;
  39   1        
  40   1      }
  41          
  42          /*
  43          #############################################################################
  44                  Peripheric initialize
  45          #############################################################################
  46          */
  47          
  48          void Init_SPI() 
  49          {
  50   1        
  51   1        //Interruptions
  52   1        //EIE1 |= 0x01;
  53   1        
  54   1        // Active Crossbar
C51 COMPILER V9.55   SPI_MASTER                                                            05/23/2019 16:49:15 PAGE 2   

  55   1        XBR0 |= 0x02;  //Route les 4 ports de la SPI et les 2 de l'UART0;
  56   1        
  57   1        
  58   1        // Activation des ports 
  59   1        P0MDOUT |= 0xFF;
  60   1        P0MDOUT &= 0xFD;
  61   1        P1MDOUT |= 0xFF;
  62   1        
  63   1        SPI0CFG = 0x87;//Configure CLK SPI (actif front montant) + transmission des 8 bits
  64   1        SPI0CN |= 0x02; //active mode master
  65   1        SPI0CKR = 0x48; //On definit la fréquence SCK a 150kHz (elle doit etre comprise entre 100 et 200kHz pour 
             -une bonne optimisation)
  66   1        
  67   1        slave_selector = SLAVE_ENABLE;
  68   1        
  69   1        SPI0CN |= 0x01; //active la SPI
  70   1      }
  71          
  72          /*
  73          #############################################################################
  74                  Pour µP 8051F020
  75          #############################################################################
  76          */
  77          
  78          void spi_send_char(char a){
  79   1          slave_selector = SLAVE_ENABLE;
  80   1          
  81   1          SPI0DAT = a;
  82   1          // Wait until the end of transmission
  83   1          while(TXBSY == 1) {}
  84   1          
  85   1          slave_selector = SLAVE_DISEABLE;
  86   1      }
  87          
  88          void spi_transmit(SPI_PACKET* spi_packet)
  89          {
  90   1        byte ptr = 0;
  91   1        byte _delay = 0;
  92   1        
  93   1        // Reset Buffer before transmission
  94   1        memset(spi_data_in, 0 , spi_data_in_ptr);
  95   1        spi_data_in_ptr = 0;
  96   1        
  97   1        // Enable Interrupt
  98   1        EIE1 |= 0x01;
  99   1        
 100   1        while(ptr < TRAM_SIZE)
 101   1        {
 102   2          spi_send_char(spi_packet->send_data[ptr]);
 103   2          ptr++;
 104   2          // Wait at least 2 CLK before update SPIODAT
 105   2          for(_delay = 0 ; _delay < 20 ; _delay++);
 106   2        }
 107   1      
 108   1        // DISEABLE INTERRUPT
 109   1        EIE1 &= 0xFE;
 110   1      
 111   1        // Check if received _data are correct througth SPI Slave Flag 'VALID'
 112   1        if(spi_validate() == 0)
 113   1        {
 114   2          spi_error();
 115   2        }
C51 COMPILER V9.55   SPI_MASTER                                                            05/23/2019 16:49:15 PAGE 3   

 116   1        else{
 117   2          spi_packet->ready = 1;
 118   2        }
 119   1        
 120   1        // Get DATA
 121   1        spi_packet->received_data = spi_data_in;
*** WARNING C182 IN LINE 121 OF src\spi_master.c: pointer to different objects
 122   1        
 123   1        memset(spi_data_out, 0, ptr);
 124   1        
 125   1      }
 126          
 127          void spi_process(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 128          {
 129   1        if(cmd->Etat_ACQ_Son == ACQ_oui)
 130   1        {
 131   2          spi_cmd_acq_sound(cmd, spi_packet);
 132   2          cmd->Etat_ACQ_Son = ACQ_non;
 133   2          spi_packet->ready = 1;
 134   2        }
 135   1        else if(cmd->Etat_GEN_Son == GEN_oui)
 136   1        {
 137   2          spi_cmd_generate_sound(cmd, spi_packet);
 138   2          cmd->Etat_GEN_Son = GEN_non;
 139   2          spi_packet->ready = 1;
 140   2        }
 141   1        else if(cmd->Etat_Lumiere != Lumiere_non)
 142   1        {
 143   2          if(cmd->Etat_Lumiere == Allumer)
 144   2          {
 145   3            spi_cmd_light_ON(cmd, spi_packet);
 146   3            cmd->Etat_Lumiere = Lumiere_non;
 147   3            spi_packet->ready = 1;
 148   3          }
 149   2          else
 150   2          {
 151   3            spi_cmd_light_OFF(cmd, spi_packet);
 152   3            cmd->Etat_Lumiere = Lumiere_non;
 153   3            spi_packet->ready = 1;
 154   3          }
 155   2        }
 156   1        else if(cmd->Etat_Servo == Servo_V)
 157   1        {
 158   2          spi_cmd_servo(cmd, spi_packet);
 159   2          cmd->Etat_Servo = Servo_non;
 160   2          spi_packet->ready = 1;
 161   2        }
 162   1        else if(cmd->Etat_Photo != Photo_non)
 163   1        {
 164   2          if(cmd->Etat_Photo != Photo_stop)
 165   2          {
 166   3            spi_cmd_photo_ON(cmd, spi_packet);
 167   3            cmd->Etat_Photo = Photo_non;
 168   3            spi_packet->ready = 1;
 169   3          }
 170   2          else
 171   2          {
 172   3            spi_cmd_photo_OFF(cmd, spi_packet);
 173   3            cmd->Etat_Photo = Photo_non;
 174   3            spi_packet->ready = 1;
 175   3          }
 176   2        }
C51 COMPILER V9.55   SPI_MASTER                                                            05/23/2019 16:49:15 PAGE 4   

 177   1        else
 178   1        {
 179   2      
 180   2        }
 181   1        
 182   1        
 183   1        if(spi_packet->ready == 1)
 184   1        {
 185   2          spi_transmit(spi_packet);
 186   2          spi_packet->ready = 0;
 187   2        }
 188   1        
 189   1      }
 190          
 191          void spi_cmd_servo(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 192          {
 193   1        spi_packet->send_data[0] = SPI_SERVO_CMD;
 194   1        spi_packet->send_data[1] = (cmd->Servo_Angle);
 195   1        spi_packet->send_data[2] = (cmd->Servo_Angle) >> 8;
 196   1        spi_packet->send_data[3] = 0;
 197   1        spi_packet->send_data[4] = 0;
 198   1      }
 199          
 200          void spi_cmd_light_ON(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 201          {
 202   1        spi_packet->send_data[0] = SPI_LIGHT_ON_CMD;
 203   1        spi_packet->send_data[1] = (cmd->Lumiere_Intensite);
 204   1        spi_packet->send_data[2] = (cmd->Lumiere_Duree);
 205   1        spi_packet->send_data[3] = (cmd->Lumire_Extinction);
 206   1        spi_packet->send_data[4] = (cmd->Lumiere_Nbre);
 207   1        
 208   1      }
 209          
 210          void spi_cmd_light_OFF(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 211          {
 212   1        /* For Warning Suppression */
 213   1        cmd = cmd;
 214   1        
 215   1        spi_packet->send_data[0] = SPI_LIGHT_OFF_CMD;
 216   1        spi_packet->send_data[1] = 0;
 217   1        spi_packet->send_data[2] = 0;
 218   1        spi_packet->send_data[3] = 0;
 219   1        spi_packet->send_data[4] = 0;
 220   1        
 221   1      }
 222          
 223          void spi_cmd_generate_sound(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 224          {
 225   1        spi_packet->send_data[0] = SPI_GENERATE_SOUND_CMD;
 226   1        spi_packet->send_data[1] = (cmd->GEN_freq_code);
 227   1        spi_packet->send_data[2] = (cmd->GEN_son_Duree);
 228   1        spi_packet->send_data[3] = (cmd->GEN_silence_Duree);
 229   1        spi_packet->send_data[4] = (cmd->GEN_nbr_bip);
 230   1      }
 231          
 232          void spi_cmd_acq_sound(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 233          {
 234   1        spi_packet->send_data[0] = SPI_ACQ_SOUND_CMD;
 235   1        spi_packet->send_data[1] = (cmd->ACQ_Duree);
 236   1        spi_packet->send_data[2] = 0;
 237   1        spi_packet->send_data[3] = 0;
 238   1        spi_packet->send_data[4] = 0;
C51 COMPILER V9.55   SPI_MASTER                                                            05/23/2019 16:49:15 PAGE 5   

 239   1      }
 240          
 241          void spi_cmd_photo_ON(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 242          {
 243   1        /* For Warning Suppression */
 244   1        cmd = cmd;
 245   1        
 246   1        spi_packet->send_data[0] = SPI_PHOTO_ON_CMD;
 247   1        spi_packet->send_data[1] = cmd->Etat_Photo;
 248   1        spi_packet->send_data[2] = cmd->Photo_Duree;
 249   1        spi_packet->send_data[3] = cmd->Photo_Nbre;
 250   1        spi_packet->send_data[4] = 0;
 251   1        
 252   1      }
 253          
 254          void spi_cmd_photo_OFF(OUT_M1 * cmd, SPI_PACKET* spi_packet)
 255          {
 256   1        /* For Warning Suppression */
 257   1        cmd = cmd;
 258   1        
 259   1        spi_packet->send_data[0] = SPI_PHOTO_OFF_CMD;
 260   1        spi_packet->send_data[1] = 0;
 261   1        spi_packet->send_data[2] = 0;
 262   1        spi_packet->send_data[3] = 0;
 263   1        spi_packet->send_data[4] = 0;
 264   1      }
 265          
 266          byte spi_validate()
 267          {
 268   1        int hash = 0, i =0;
 269   1        
 270   1        for(i = 0; i < 5 ; i++)
 271   1        {
 272   2          hash += spi_data_in[i];
 273   2        }
 274   1        
 275   1        if(hash != 368)
 276   1        {
 277   2          return 0;
 278   2        }
 279   1        else 
 280   1        {
 281   2          return 1;
 282   2        }
 283   1      }
 284          
 285          void spi_error()
 286          {
 287   1        spi_data_in[0] = 'E';
 288   1        spi_data_in[1] = 'R';
 289   1        spi_data_in[2] = 'R';
 290   1        spi_data_in[3] = 'O';
 291   1        spi_data_in[4] = 'R';
 292   1      }
 293          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2554    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     69    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.55   SPI_MASTER                                                            05/23/2019 16:49:15 PAGE 6   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
