C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     05/14/2019 09:17:25 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE DISTANCE_DETECTOR
OBJECT MODULE PLACED IN .\Objects\distance_detector.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\distance_detector.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\distance_detector.lst) TABS(2) OBJECT(.\Objects\distance_detector.obj)

line level    source

   1          //
   2          // Target: C8051F02x
   3          // Tool chain: KEIL Microvision 4
   4          //
   5          //  NOM: METEYER
   6          
   7          //
   8          //------------------------------------------------------------------------------------
   9          #include "distance_detector.h"
  10          #include "adc.h"
  11          
  12          //port de sortie
  13          sbit P1_2 = P1^2;
  14          
  15          
  16          volatile int servo_angle_H = 0;
  17          
  18          PWN_STATE pwn_state = PWN_IDDLE;
  19          
  20          DD_STATE dd_current_state = DD_IDLE;
  21          int nbr_interrupt = 0;
  22          
  23          int val_obs_buffer[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  24          byte val_obs_buffer_size = 0;
  25          
  26          /*
  27              FULL STATE MACHINE
  28          
  29              Liste des Etats de la machines d'état associés à leur fonction
  30          */
  31          const DD_FSM_PROCESS dd_full_state_machine[5] = {
  32              {DD_IDLE, &dd_idle},
  33              {MOVE_SERVO_H, &dd_move_servo_h},
  34              {SINGLE_MEASURE, &dd_single_measure},
  35              {SLEW_DETECTION, &dd_slew_detection},
  36              {OBS_DETECTION, &dd_obs_detection}
  37          };
  38          
  39          /*
  40          #############################################################################
  41                  Interrupt Routine For Timer 0
  42          #############################################################################
  43          */
  44            
  45          void timer_0_int() interrupt 1
  46          { 
  47   1        static char high = 0;
  48   1        
  49   1        int duree_imp = 0;
  50   1        int reload_value = 0;
  51   1      
  52   1        duree_imp = 10*(servo_angle_H+90) + 600 ;// 600us pour 90°  (cf doc technique)
  53   1        
  54   1        P1_2 = !P1_2;
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     05/14/2019 09:17:25 PAGE 2   

  55   1        
  56   1        if (high == 0)
  57   1        {
  58   2          reload_value = 0xFFFF - (2*6000 - duree_imp );
  59   2          high=1;
  60   2        } else {
  61   2          
  62   2          reload_value = 0xFFFF - (2 * duree_imp );
  63   2          high=0;
  64   2        }
  65   1        TL0= reload_value;
  66   1        TH0= reload_value >> 8; //on décale pour obtenir les bits de poids fort
  67   1        
  68   1        if(nbr_interrupt == 1000)
  69   1        {
  70   2          //ET0 = 0;  // Enable timer0 interuption
  71   2          nbr_interrupt++;
  72   2          pwn_state = PWN_FINISH;
  73   2        }
  74   1        else
  75   1        {
  76   2          nbr_interrupt++;
  77   2        }
  78   1      }
  79          
  80          /*
  81          #############################################################################
  82                  End of Interrupt Routine For Timer 0
  83          #############################################################################
  84          */
  85          
  86          /*
  87          #############################################################################
  88                  Peripheric initialize
  89          #############################################################################
  90          */
  91          
  92          
  93          void Init_distance_detector()
  94          {
  95   1        //dd_config_DAC_ADC();
  96   1        
  97   1        
  98   1        // XBAR for servomoteur H
  99   1        //XBR1 |=0x02; 
 100   1        
 101   1        /* XBAR for telemeter */
 102   1        //XBR1 |= 0x80;
 103   1        
 104   1        // Push-Pull mode
 105   1        P1MDOUT = 0xFF;
 106   1        
 107   1        dd_init_timer0();
 108   1        
 109   1        ET0 = 1;  // Enable timer0 interuption
 110   1        EA = 1; // Enable general interruption
 111   1      }
 112          
 113          void dd_init_timer0()
 114          { 
 115   1        //Reglages Timer 0
 116   1        TMOD=0x01; //mode 1
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     05/14/2019 09:17:25 PAGE 3   

 117   1        TCON= 0x11; // Enable Timer0 (bit4) and enable interupt on edge (bit0)
 118   1        TL0=0xA8;
 119   1        TH0=0xFB;
 120   1        
 121   1        TR0 = 1;
 122   1      }
 123          
 124          
 125          
 126          /*
 127          #############################################################################
 128                  Distance Detector Core
 129          #############################################################################
 130          */
 131          
 132          //const FSM_PROCESS* cmd_parser_next_state()
 133          void distance_detector_process(DD_PACKET * dd_packet)
 134          {
 135   1        dd_full_state_machine[dd_current_state].state_process(dd_packet);
 136   1      }
 137          
 138          
 139          void dd_idle(DD_PACKET * dd_packet)
 140          {
 141   1        if(dd_packet->commands->Etat_DCT_Obst != DCT_non)
 142   1        {
 143   2          switch(dd_packet->commands->Etat_DCT_Obst)
 144   2          {
 145   3            case oui_180:
 146   3              dd_current_state = SLEW_DETECTION;
 147   3              break;
 148   3            
 149   3            case oui_360:
 150   3              
 151   3              break;
 152   3            
 153   3            case oui_single:
 154   3              dd_current_state = SINGLE_MEASURE;
 155   3              break;
 156   3            default:
 157   3              dd_current_state = DD_IDLE;
 158   3          }
 159   2        }
 160   1        else
 161   1        {
 162   2          if(dd_packet->commands->Etat_Servo == Servo_H)
 163   2          {
 164   3            dd_current_state = MOVE_SERVO_H;
 165   3            dd_packet->commands->Etat_Servo = Servo_non;
 166   3          }
 167   2        
 168   2        }
 169   1      
 170   1      }
 171          
 172          void dd_move_servo_h(DD_PACKET * dd_packet)
 173          {
 174   1        if(pwn_state == PWN_IDDLE)
 175   1        {
 176   2          ET0 = 0;  // Stop last PWN Interrupt routine
 177   2          dd_set_angle(dd_packet->commands->Servo_Angle);
 178   2          nbr_interrupt = 0; // Reset tempo flag
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     05/14/2019 09:17:25 PAGE 4   

 179   2          pwn_state = PWN_RUN;
 180   2          ET0 = 1;  // Enable timer0 interuption
 181   2          
 182   2        }
 183   1        else if (pwn_state == PWN_FINISH)
 184   1        {
 185   2          dd_packet->informations->Etat_BUT_Servo = BUT_Servo_H;
 186   2          dd_packet->informations->Etat_Invite = Invite_oui;
 187   2          pwn_state = PWN_IDDLE;
 188   2          dd_current_state = DD_IDLE;
 189   2        }
 190   1        else{
 191   2          // Nothing to do
 192   2        }
 193   1        
 194   1      
 195   1      }
 196          
 197          void dd_slew_detection(DD_PACKET * dd_packet)
 198          {
 199   1        static byte step = 0;
 200   1        static char delta_angle = -90;
 201   1        static float smallest_measure = 70.0;
 202   1        static char angle_obs = 0;
 203   1        
 204   1        switch(step)
 205   1        {
 206   2          case 0:
 207   2            dd_set_angle(-90);
 208   2            dd_packet->commands->DCT_Obst_Resolution = 5;
 209   2            step++;
 210   2            break;
 211   2          case 1:
 212   2            delta_angle += dd_packet->commands->DCT_Obst_Resolution;
 213   2            // TODO
 214   2            /**dd_set_angle(delta_angle);
 215   2            if(delta_angle == 90)
 216   2            {
 217   2              step++;
 218   2            }
 219   2            dd_current_state = SINGLE_MEASURE;*/
 220   2            break;
 221   2          default:
 222   2            delta_angle = -90;
 223   2            step = 0;
 224   2            dd_current_state = DD_IDLE;
 225   2            break;
 226   2        }
 227   1      }
*** WARNING C280 IN LINE 201 OF src\distance_detector.c: 'smallest_measure': unreferenced local variable
*** WARNING C280 IN LINE 202 OF src\distance_detector.c: 'angle_obs': unreferenced local variable
 228          
 229          void dd_single_measure(DD_PACKET * dd_packet)
 230          {
 231   1        clear_val_obs_buffer();
 232   1        
 233   1        // Front telemeter
 234   1        choose_ADC_input(AIN0);
 235   1        dd_packet->measure = dd_start_conversion();
 236   1      
 237   1        if(dd_packet->measure <= MAX_DISTANCE)
 238   1        {
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     05/14/2019 09:17:25 PAGE 5   

 239   2          val_obs_buffer[0] = (int)(10 * dd_packet->measure);
 240   2          val_obs_buffer[1] = servo_angle_H;
 241   2          dd_packet->obs_detected_front = 1;
 242   2        }
 243   1        else
 244   1        {
 245   2          dd_packet->obs_detected_front = 0;
 246   2        }
 247   1        
 248   1        // Back telemeter
 249   1        choose_ADC_input(AIN1);
 250   1        dd_packet->measure = dd_start_conversion();
 251   1      
 252   1        if(dd_packet->measure <= MAX_DISTANCE)
 253   1        {
 254   2          val_obs_buffer[2] = (int)(10 * dd_packet->measure);
 255   2          val_obs_buffer[3] = servo_angle_H;
 256   2          dd_packet->obs_detected_back = 1;
 257   2        }
 258   1        else
 259   1        {
 260   2          dd_packet->obs_detected_back = 0;
 261   2        }
 262   1        
 263   1        dd_packet->informations->Tab_Val_Obst = val_obs_buffer;
*** WARNING C182 IN LINE 263 OF src\distance_detector.c: pointer to different objects
 264   1        dd_packet->informations->Nbre_Val_obst = val_obs_buffer_size;
 265   1        
 266   1        // Switch ON "KOB" info return
 267   1        dd_packet->informations->Etat_DCT_Obst = DCT_Obst_single_oui;
 268   1        dd_packet->informations->Etat_Invite = Invite_oui;
 269   1        
 270   1        dd_packet->commands->Etat_DCT_Obst = DCT_non;
 271   1        
 272   1        dd_current_state = DD_IDLE;
 273   1      }
 274          
 275          void dd_set_angle(int angle)
 276          {
 277   1        servo_angle_H = angle;
 278   1      }
 279          
 280          void clear_val_obs_buffer()
 281          {
 282   1        byte i = 0;
 283   1        
 284   1        for(i = 0 ; i < VAL_OBS_BUFFER_SIZE ; i++)
 285   1        {
 286   2          val_obs_buffer[i] = 0;
 287   2        }
 288   1        val_obs_buffer_size = 0;
 289   1      }
 290          
 291          float dd_mesure(){
 292   1        
 293   1        float d;
 294   1        float V_mes;
 295   1        
 296   1        V_mes=_read_ADC0()/(POW*5.6);
 297   1        
 298   1        //Calcul des distances
 299   1        d=-16.669*V_mes+MAX_DISTANCE; 
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     05/14/2019 09:17:25 PAGE 6   

 300   1        
 301   1        return d;
 302   1        
 303   1      } 
 304          
 305          
 306          float dd_start_conversion(){
 307   1        float conv;
 308   1        unsigned int j;
 309   1        AD0INT=0;
 310   1        AD0BUSY=1;
 311   1        dd_mesure();
 312   1        AD0BUSY=0;
 313   1        
 314   1        for(j=0;j<1000;j++); //On temporise pour atteindre la stabilité
 315   1        
 316   1        AD0INT=0;
 317   1        AD0BUSY=1;
 318   1        conv =dd_mesure();
 319   1        AD0BUSY=0;
 320   1        
 321   1        return conv;
 322   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1523    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     55      36
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
