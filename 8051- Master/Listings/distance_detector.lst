C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     04/18/2019 18:35:49 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE DISTANCE_DETECTOR
OBJECT MODULE PLACED IN .\Objects\distance_detector.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\distance_detector.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\distance_detector.lst) TABS(2) OBJECT(.\Objects\distance_detector.obj)

line level    source

   1          //
   2          // Target: C8051F02x
   3          // Tool chain: KEIL Microvision 4
   4          //
   5          //  NOM: METEYER
   6          
   7          //
   8          //------------------------------------------------------------------------------------
   9          #include "distance_detector.h"
  10          
  11          //port de sortie
  12          sbit P1_2 = P1^2;
  13          
  14          sfr16 ADC0 = 0xbe;
  15          
  16          volatile int servo_angle_H = 0;
  17          
  18          byte pwn_over = 0;
  19          
  20          DD_STATE dd_current_state = DD_IDLE;
  21          
  22          /*
  23              FULL STATE MACHINE
  24          
  25              Liste des Etats de la machines d'état associés à leur fonction
  26          */
  27          const DD_FSM_PROCESS dd_full_state_machine[5] = {
  28              {DD_IDLE, &dd_idle},
  29              {MOVE_SERVO_H, &dd_move_servo_h},
  30              {SINGLE_MEASURE, &dd_single_measure},
  31              {SLEW_DETECTION, &dd_slew_detection},
  32              {OBS_DETECTION, &dd_obs_detection}
  33          };
  34          
  35          /*
  36          #############################################################################
  37                  Interrupt Routine For Timer 0
  38          #############################################################################
  39          */
  40            
  41          void timer_0_int() interrupt 1
  42          { 
  43   1        static byte nbr_interrupt = 0;
  44   1        static char high = 0;
  45   1        
  46   1        int duree_imp = 0;
  47   1        int reload_value = 0;
  48   1      
  49   1        duree_imp = 10*(servo_angle_H+90) + 600 ;// 600us pour 90°  (cf doc technique)
  50   1        
  51   1        P1_2 = !P1_2;
  52   1        
  53   1        if (high == 0)
  54   1        {
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     04/18/2019 18:35:49 PAGE 2   

  55   2          reload_value = 0xFFFF - (2*6000 - duree_imp );
  56   2          high=1;
  57   2        } else {
  58   2          
  59   2          reload_value = 0xFFFF - (2 * duree_imp );
  60   2          high=0;
  61   2        }
  62   1        TL0= reload_value;
  63   1        TH0= reload_value >> 8; //on décale pour obtenir les bits de poids fort
  64   1        
  65   1        if(nbr_interrupt >= 150)
  66   1        {
  67   2          ET0 = 0;  // Enable timer0 interuption
  68   2          nbr_interrupt = 0;
  69   2          pwn_over = 1;
  70   2        }
  71   1        else
  72   1        {
  73   2          nbr_interrupt++;
  74   2        }
  75   1      }
  76          
  77          /*
  78          #############################################################################
  79                  End of Interrupt Routine For Timer 0
  80          #############################################################################
  81          */
  82          
  83          /*
  84          #############################################################################
  85                  Peripheric initialize
  86          #############################################################################
  87          */
  88          
  89          
  90          void Init_distance_detector()
  91          {
  92   1        dd_config_DAC_ADC();
  93   1        
  94   1        
  95   1        // XBAR for servomoteur H
  96   1        //XBR1 |=0x02; 
  97   1        
  98   1        /* XBAR for telemeter */
  99   1        //XBR1 |= 0x80;
 100   1        
 101   1        // Push-Pull mode
 102   1        P1MDOUT = 0xFF;
 103   1        
 104   1        dd_init_timer0();
 105   1        
 106   1        ET0 = 1;  // Enable timer0 interuption
 107   1        EA = 1; // Enable general interruption
 108   1      }
 109          
 110          void dd_init_timer0()
 111          { 
 112   1        //Reglages Timer 0
 113   1        TMOD=0x01; //mode 1
 114   1        TCON= 0x11; // Enable Timer0 (bit4) and enable interupt on edge (bit0)
 115   1        TL0=0xA8;
 116   1        TH0=0xFB;
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     04/18/2019 18:35:49 PAGE 3   

 117   1        
 118   1        TR0 = 1;
 119   1      }
 120          
 121          void dd_config_DAC_ADC() {
 122   1      
 123   1        ADC0CN |=0x81;
 124   1        ADC0CN &= ~0x4C;
 125   1        ADC0CF &= 0x00;
 126   1        //AMX0SL&=0xF0;
 127   1        //AMX0CF&=0xF0;
 128   1      
 129   1        REF0CN&=0xEB;
 130   1        REF0CN|=0x03;
 131   1        
 132   1        DAC0CN |=0x80;
 133   1        DAC0CN &=0xE0;
 134   1      }
 135          
 136          /*
 137          #############################################################################
 138                  Distance Detector Core
 139          #############################################################################
 140          */
 141          
 142          //const FSM_PROCESS* cmd_parser_next_state()
 143          void distance_detector_process(DD_PACKET * dd_packet)
 144          {
 145   1        dd_full_state_machine[dd_current_state].state_process(dd_packet);
 146   1      }
 147          
 148          
 149          void dd_idle(DD_PACKET * dd_packet)
 150          {
 151   1        if(dd_packet->commands->Etat_DCT_Obst != DCT_non)
 152   1        {
 153   2          switch(dd_packet->commands->Etat_DCT_Obst)
 154   2          {
 155   3            case oui_180:
 156   3              dd_current_state = SLEW_DETECTION;
 157   3              break;
 158   3            
 159   3            case oui_360:
 160   3              
 161   3              break;
 162   3            
 163   3            default:
 164   3              dd_current_state = DD_IDLE;
 165   3          }
 166   2        }
 167   1        else
 168   1        {
 169   2          if(dd_packet->commands->Etat_Servo == Servo_H)
 170   2          {
 171   3            dd_current_state = MOVE_SERVO_H;
 172   3            dd_packet->commands->Etat_Servo = Servo_non;
 173   3          }
 174   2        }
 175   1      
 176   1      }
 177          
 178          void dd_move_servo_h(DD_PACKET * dd_packet)
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     04/18/2019 18:35:49 PAGE 4   

 179          {
 180   1        dd_set_angle(dd_packet->commands->Servo_Angle);
 181   1        pwn_over = 0;
 182   1        ET0 = 1;  // Enable timer0 interuption
 183   1        dd_current_state = DD_IDLE;
 184   1      }
 185          
 186          void dd_slew_detection(DD_PACKET * dd_packet)
 187          {
 188   1        static byte step = 0;
 189   1        static char delta_angle = -90;
 190   1        static float smallest_measure = 70.0;
 191   1        static char angle_obs = 0;
 192   1        
 193   1        switch(step)
 194   1        {
 195   2          case 0:
 196   2            dd_set_angle(-90);
 197   2            dd_packet->commands->DCT_Obst_Resolution = 5;
 198   2            step++;
 199   2            break;
 200   2          case 1:
 201   2            delta_angle += dd_packet->commands->DCT_Obst_Resolution;
 202   2            dd_set_angle(delta_angle);
 203   2            if(delta_angle == 90)
 204   2            {
 205   3              step++;
 206   3            }
 207   2            dd_current_state = SINGLE_MEASURE;
 208   2            break;
 209   2          default:
 210   2            delta_angle = -90;
 211   2            step = 0;
 212   2            dd_current_state = DD_IDLE;
 213   2            break;
 214   2        }
 215   1      }
*** WARNING C280 IN LINE 190 OF src\distance_detector.c: 'smallest_measure': unreferenced local variable
*** WARNING C280 IN LINE 191 OF src\distance_detector.c: 'angle_obs': unreferenced local variable
 216          
 217          void dd_set_angle(int angle)
 218          {
 219   1        servo_angle_H = angle;
 220   1      }
 221          
 222          
 223          float dd_mesure(){
 224   1        
 225   1        float d;
 226   1        float V_mes;
 227   1        
 228   1        //lecture de la tension mesurée sur AIN2
 229   1        AMX0SL&=0x00;
 230   1        AMX0SL|=0x01;
 231   1        
 232   1        V_mes=ADC0/(POW*5.6);
 233   1        
 234   1        //Calcul des distances
 235   1        d=-16.669*V_mes+67.367; 
 236   1        //putchar((char)d);
 237   1        
 238   1        return d;
C51 COMPILER V9.55   DISTANCE_DETECTOR                                                     04/18/2019 18:35:49 PAGE 5   

 239   1        
 240   1      } 
 241          
 242          
 243          float dd_start_conversion(){
 244   1        float conv;
 245   1        unsigned int j;
 246   1        AD0INT=0;
 247   1        AD0BUSY=1;
 248   1        dd_mesure();
 249   1        AD0BUSY=0;
 250   1        
 251   1        for(j=0;j<1000;j++); //On temporise pour atteindre la stabilité
 252   1        
 253   1        AD0INT=0;
 254   1        AD0BUSY=1;
 255   1        conv =dd_mesure();
 256   1        AD0BUSY=0;
 257   1        
 258   1        return conv;
 259   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    904    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     33      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
