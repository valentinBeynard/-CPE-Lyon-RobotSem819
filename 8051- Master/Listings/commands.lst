C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COMMANDS
OBJECT MODULE PLACED IN .\Objects\commands.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\commands.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\commands.lst) TABS(2) OBJECT(.\Objects\commands.obj)

line level    source

   1          #include "commands.h"
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          byte default_process(CMD_PACKET* cmd_packet)
   7          {
   8   1        //printf("Non-implemented command !!");
   9   1        cmd_packet->commands->Etat_Epreuve = (enum Epreuve)1;
  10   1        
  11   1        return 1;
  12   1      }
  13          
  14          /*
  15            Commande de démarage de l'épreuve : D [Numéro Epreuve]
  16            Si aucun paramètre rentré, alors on démarre à l'épreuve 1
  17          */
  18          byte epreuve_cmd(CMD_PACKET* cmd_packet)
  19          {
  20   1        int epreuve_index = 1;
  21   1      
  22   1        // Trop d'argument
  23   1        if(cmd_packet->cmd_size > 1)
  24   1        {
  25   2          return 0;
  26   2        }
  27   1      
  28   1        // Si le paramètre correspondant au numéro d'épreuve est présent
  29   1        if(cmd_packet->cmd_size == 1)
  30   1        {
  31   2          // Si valeur non numérique
  32   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%u", &epreuve_index) != 1)
  33   2          {
  34   3            return 0;
  35   3          }
  36   2      
  37   2          // Si pas dans l'intervalle de valeur acceptées
  38   2          if(epreuve_index < 1 || epreuve_index > 9)
  39   2          {
  40   3            return 0;
  41   3          }
  42   2          
  43   2          cmd_packet->commands->Etat_Epreuve = (enum Epreuve)epreuve_index;
  44   2        }
  45   1        else
  46   1        {
  47   2          cmd_packet->commands->Etat_Epreuve = epreuve1;
  48   2        }
  49   1        return 1;
  50   1      }
  51          
  52          byte epreuve_stop(CMD_PACKET* cmd_packet)
  53          {
  54   1        //printf("Non-implemented command !!");
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 2   

  55   1        cmd_packet->commands->Etat_Epreuve = Epreuve_non;
  56   1        
  57   1        return 1;
  58   1      }
  59          
  60          
  61          byte safety_break_cmd(CMD_PACKET* cmd_packet)
  62          {
  63   1        // Trop d'argument
  64   1        if(cmd_packet->cmd_size > 0)
  65   1        {
  66   2          return 0;
  67   2        }
  68   1      
  69   1        cmd_packet->commands->Etat_Epreuve = Stop_Urgence;
  70   1        
  71   1        return 1;
  72   1      }
  73          
  74          byte set_default_speed_cmd(CMD_PACKET* cmd_packet)
  75          {
  76   1        int motor_speed = 20;
  77   1        
  78   1        // Seu la commande TV valeur est acceptée
  79   1        if(cmd_packet->cmd_size != 1)
  80   1        {
  81   2          return 0;
  82   2        }
  83   1        
  84   1        // Si valeur non numérique
  85   1        if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) != 1)
  86   1        {
  87   2          return 0;
  88   2        }
  89   1        
  90   1        // Si pas dans l'intervalle de valeur acceptées
  91   1        if(motor_speed < 0 || motor_speed > 100)
  92   1        {
  93   2          return 0;
  94   2        }
  95   1        
  96   1        cmd_packet->commands->Vitesse = motor_speed;
  97   1      
  98   1        return 1;
  99   1      }
 100          
 101          byte move_forward_cmd(CMD_PACKET* cmd_packet)
 102          {
 103   1        int motor_speed = 20;
 104   1        
 105   1        if(cmd_packet->cmd_size > 1)
 106   1        {
 107   2          return 0;
 108   2        }
 109   1          
 110   1        cmd_packet->commands->Etat_Mouvement = Avancer;
 111   1      
 112   1        if(cmd_packet->cmd_size == 1)
 113   1        {
 114   2          // Si valeur non numérique
 115   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 116   2          {
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 3   

 117   3            return 0;
 118   3          }
 119   2          
 120   2          // Si pas dans l'intervalle de valeur acceptées
 121   2          if(motor_speed < 0 || motor_speed > 100)
 122   2          {
 123   3            return 0;
 124   3          }
 125   2          
 126   2          cmd_packet->commands->Vitesse = motor_speed;
 127   2        }else{
 128   2          if(cmd_packet->commands->Vitesse == 0)
 129   2          {
 130   3            cmd_packet->commands->Vitesse = motor_speed;
 131   3          }
 132   2        }
 133   1        return 1;
 134   1      }
 135          
 136          byte move_backward_cmd(CMD_PACKET* cmd_packet)
 137          {
 138   1        int motor_speed = 20;
 139   1        
 140   1        if(cmd_packet->cmd_size > 1)
 141   1        {
 142   2          return 0;
 143   2        }
 144   1          
 145   1        cmd_packet->commands->Etat_Mouvement = Reculer;
 146   1      
 147   1        if(cmd_packet->cmd_size == 1)
 148   1        {
 149   2          // Si valeur non numérique
 150   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 151   2          {
 152   3            return 0;
 153   3          }
 154   2          
 155   2          // Si pas dans l'intervalle de valeur acceptées
 156   2          if(motor_speed < 0 || motor_speed > 100)
 157   2          {
 158   3            return 0;
 159   3          }
 160   2          
 161   2          cmd_packet->commands->Vitesse = motor_speed;
 162   2        }else{
 163   2          if(cmd_packet->commands->Vitesse == 0)
 164   2          {
 165   3            cmd_packet->commands->Vitesse = motor_speed;
 166   3          }
 167   2        }
 168   1        return 1;
 169   1      }
 170          
 171          byte move_stop_cmd(CMD_PACKET* cmd_packet)
 172          { 
 173   1        if(cmd_packet->cmd_size != 0)
 174   1        {
 175   2          return 0;
 176   2        }
 177   1        cmd_packet->commands->Etat_Mouvement = Stopper;
 178   1        return 1;
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 4   

 179   1      }
 180          
 181          byte rigth_rotation_cmd(CMD_PACKET* cmd_packet)
 182          {
 183   1        if(cmd_packet->cmd_size != 0)
 184   1        {
 185   2          return 0;
 186   2        }
 187   1        
 188   1        cmd_packet->commands->Etat_Mouvement = Rot_90D;
 189   1        return 1;
 190   1      }
 191          
 192          byte left_rotation_cmd(CMD_PACKET* cmd_packet)
 193          {
 194   1        if(cmd_packet->cmd_size != 0)
 195   1        {
 196   2          return 0;
 197   2        }
 198   1        
 199   1        cmd_packet->commands->Etat_Mouvement = Rot_90G;
 200   1        return 1;
 201   1      }
 202          
 203          byte complete_rotation_cmd(CMD_PACKET* cmd_packet)
 204          {
 205   1        if(cmd_packet->cmd_size > 1)
 206   1        {
 207   2          return 0;
 208   2        }
 209   1      
 210   1        if(cmd_packet->cmd_size == 1)
 211   1        {
 212   2          
 213   2          if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "D") == 0 
 214   2            || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "G") == 0)
 215   2          {
 216   3            switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 217   3            {
 218   4              case 'D':
 219   4                cmd_packet->commands->Etat_Mouvement = Rot_180D;
 220   4                break;
 221   4              default :
 222   4                cmd_packet->commands->Etat_Mouvement = Rot_180G;
 223   4                break;
 224   4            }
 225   3          }else{
 226   3            return 0;
 227   3          }
 228   2      
 229   2        }else{
 230   2          cmd_packet->commands->Etat_Mouvement = Rot_180D;
 231   2        }
 232   1        return 1;
 233   1      }
 234          
 235          byte angle_rotation_cmd(CMD_PACKET* cmd_packet)
 236          {
 237   1        unsigned int angle = 0;
 238   1        
 239   1        if(cmd_packet->cmd_size != 2)
 240   1        {
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 5   

 241   2          return 0;
 242   2        }
 243   1        
 244   1        if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "D") == 0 
 245   1            || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "G") == 0)
 246   1        {
 247   2          switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 248   2          {
 249   3            case 'D':
 250   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 251   3              break;
 252   3            default :
 253   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 254   3              break;
 255   3          }
 256   2          
 257   2          if(sscanf((cmd_packet->commands_data + (2 * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 258   2          {
 259   3            return 0;
 260   3          }
 261   2          
 262   2          cmd_packet->commands->Angle = (int)(angle);
 263   2        }else{
 264   2          return 0;
 265   2        }
 266   1        return 1;
 267   1      }
 268          
 269          /*
 270            Move to (X,Y,alpha) coordinate
 271          
 272            Ex : "G X:10 Y:15 A:45"
 273          
 274            Function exclude from Data Overlaying in "linker_directives" : OVERLAY( * ! move_to_cmd )
 275          
 276          */
 277          byte move_to_cmd(CMD_PACKET* cmd_packet)
 278          {
 279   1        byte i = 0, j = 0;
 280   1        char params[3][5] = {"X", "Y", "A"};
 281   1        int angle = 0, x = 0, y = 0;
 282   1        byte param_find = 0;
 283   1        char * str = 0;
 284   1        
 285   1        
 286   1        // Not enougthl args
 287   1        if(cmd_packet->cmd_size != 6)
 288   1        {
 289   2          return 0;
 290   2        }
 291   1        
 292   1        // Analyse each param:value couple
 293   1        for(i = 0 ; i < 3 ; ++i)
 294   1        {
 295   2          str = (cmd_packet->commands_data + ( ((2*i) + 1) * ARGS_BUFFER_SIZE));
 296   2          
 297   2          // For one couple, identify the param
 298   2          for(j = 0 ; j < 3 ; j++)
 299   2          {
 300   3            if( strcmp(str, params[j]) == 0 )
 301   3            {
 302   4              switch(j)
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 6   

 303   4              {
 304   5                case 0:
 305   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &x) == 0)
 306   5                  {
 307   6                    return 0;
 308   6                  }       
 309   5                  break;
 310   5                
 311   5                case 1:
 312   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &y) == 0)
 313   5                  {
 314   6                    return 0;
 315   6                  }   
 316   5                  break;
 317   5                
 318   5                case 2:
 319   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 320   5                  {
 321   6                    return 0;
 322   6                  } 
 323   5                  break;
 324   5                
 325   5              }
 326   4              param_find = 1;
 327   4              break;
 328   4            }
 329   3          }
 330   2          
 331   2          if(param_find == 0)
 332   2          {
 333   3            return 0;
 334   3          }else{
 335   3            param_find = 0;
 336   3          }
 337   2          
 338   2        }
 339   1        
 340   1        cmd_packet->commands->Angle = angle;
 341   1        cmd_packet->commands->Coord_X = (byte)x;
 342   1        cmd_packet->commands->Coord_Y = (byte)y;
 343   1        cmd_packet->commands->Etat_Mouvement = Depl_Coord;
 344   1        return 1;
 345   1      }
 346          
 347          byte current_measure(CMD_PACKET* cmd_packet)
 348          {
 349   1        if(cmd_packet->cmd_size != 0)
 350   1        {
 351   2          return 0;
 352   2        }
 353   1        
 354   1        cmd_packet->commands->Etat_Energie = Mesure_I;
 355   1        
 356   1        return 1;
 357   1      }
 358          
 359          byte energy_measure(CMD_PACKET* cmd_packet)
 360          {
 361   1        if(cmd_packet->cmd_size != 0)
 362   1        {
 363   2          return 0;
 364   2        }
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 7   

 365   1        
 366   1        cmd_packet->commands->Etat_Energie = Mesure_E;
 367   1        
 368   1        return 1;
 369   1      }
 370          
 371          
 372          byte detecte_obstacle(CMD_PACKET* cmd_packet)
 373          {
 374   1        if(cmd_packet->cmd_size != 0)
 375   1        {
 376   2          return 0;
 377   2        }
 378   1        
 379   1        cmd_packet->commands->Etat_DCT_Obst = oui_single;
 380   1        return 1;
 381   1      }
 382          
 383          byte servo_move_cmd(CMD_PACKET* cmd_packet)
 384          {
 385   1        int angle = 45;
 386   1        
 387   1        if(cmd_packet->cmd_size > 3)
 388   1        {
 389   2          return 0;
 390   2        }
 391   1        
 392   1        if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "H") == 0 
 393   1          || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "V") == 0)
 394   1        {
 395   2          switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 396   2          {
 397   3            case 'V':
 398   3              cmd_packet->commands->Etat_Servo = Servo_V;
 399   3              break;
 400   3            default :
 401   3              cmd_packet->commands->Etat_Servo = Servo_H;
 402   3              break;
 403   3          }
 404   2          
 405   2        }
 406   1        
 407   1        if(strcmp((cmd_packet->commands_data + (2 * ARGS_BUFFER_SIZE)), "A") == 0 )
 408   1        {
 409   2          if(sscanf((cmd_packet->commands_data + (3 * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 410   2          {
 411   3            return 0;
 412   3          }
 413   2        
 414   2          cmd_packet->commands->Servo_Angle = (char)(angle);
 415   2        }
 416   1        
 417   1        return 1;
 418   1      }
 419          
 420          byte light_beam_ON_cmd(CMD_PACKET* cmd_packet)
 421          {
 422   1        byte i = 0, j = 0;
 423   1        char params[4][5] = {"I", "D", "E", "N"};
 424   1        int intensity = 100, delay_on = 99, delay_off = 0, nbr_flash = 1;
 425   1        byte param_find = 0;
 426   1        char * str = 0;
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 8   

 427   1        
 428   1        // To much args
 429   1        if(cmd_packet->cmd_size > 8 || (cmd_packet->cmd_size % 2) != 0)
 430   1        {
 431   2          return 0;
 432   2        }
 433   1        
 434   1        // Analyse each param:value couple
 435   1        for(i = 0 ; i < (cmd_packet->cmd_size/2) ; ++i)
 436   1        {
 437   2          str = (cmd_packet->commands_data + ( ((2*i) + 1) * ARGS_BUFFER_SIZE));
 438   2          
 439   2          // For one couple, identify the param
 440   2          for(j = 0 ; j < 4 ; j++)
 441   2          {
 442   3            if( strcmp(str, params[j]) == 0 )
 443   3            {
 444   4              switch(j)
 445   4              {
 446   5                case 0:
 447   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &intensity) == 0)
 448   5                  {
 449   6                    return 0;
 450   6                  }
 451   5                  else
 452   5                  {
 453   6                    // Si pas dans l'intervalle de valeur acceptées
 454   6                    if(intensity < 1 || intensity > 100)
 455   6                    {
 456   7                      return 0;
 457   7                    }
 458   6                  }
 459   5                  break;
 460   5                
 461   5                case 1:
 462   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &delay_on) == 0)
 463   5                  {
 464   6                    return 0;
 465   6                  } 
 466   5                  else
 467   5                  {
 468   6                    // Si pas dans l'intervalle de valeur acceptées
 469   6                    if(delay_on < 1 || delay_on > 99)
 470   6                    {
 471   7                      return 0;
 472   7                    }
 473   6                  }           
 474   5                  break;
 475   5                
 476   5                case 2:
 477   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &delay_off) == 0)
 478   5                  {
 479   6                    return 0;
 480   6                  } 
 481   5                  else
 482   5                  {
 483   6                    // Si pas dans l'intervalle de valeur acceptées
 484   6                    if(delay_off < 0 || delay_off > 99)
 485   6                    {
 486   7                      return 0;
 487   7                    }
 488   6                  }   
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 9   

 489   5                  break;
 490   5                  
 491   5                case 3:
 492   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &nbr_flash) == 0)
 493   5                  {
 494   6                    return 0;
 495   6                  } 
 496   5                  else
 497   5                  {
 498   6                    // Si pas dans l'intervalle de valeur acceptées
 499   6                    if(nbr_flash < 1 || nbr_flash > 99)
 500   6                    {
 501   7                      return 0;
 502   7                    }
 503   6                  } 
 504   5                  break;
 505   5              }
 506   4              param_find = 1;
 507   4              break;
 508   4            }
 509   3          }
 510   2          
 511   2          if(param_find == 0)
 512   2          {
 513   3            return 0;
 514   3          }else{
 515   3            param_find = 0;
 516   3          }
 517   2          
 518   2        }
 519   1        
 520   1        cmd_packet->commands->Etat_Lumiere = Allumer;
 521   1        cmd_packet->commands->Lumiere_Intensite = intensity;
 522   1        cmd_packet->commands->Lumiere_Duree = delay_on;
 523   1        cmd_packet->commands->Lumire_Extinction = delay_off;
 524   1        cmd_packet->commands->Lumiere_Nbre = nbr_flash;
 525   1        
 526   1        return 1;
 527   1      }
 528          
 529          byte light_beam_OFF_cmd(CMD_PACKET* cmd_packet)
 530          {
 531   1        // To much args
 532   1        if(cmd_packet->cmd_size != 0)
 533   1        {
 534   2          return 0;
 535   2        }
 536   1      
 537   1        cmd_packet->commands->Etat_Lumiere = Eteindre;
 538   1      
 539   1        return 1;
 540   1      }
 541          
 542          byte generate_sound_cmd(CMD_PACKET* cmd_packet)
 543          {
 544   1          byte i = 0, j = 0;
 545   1        char params[4][5] = {"F", "P", "W", "B"};
 546   1        int frequency_code = 100, delay_son = 25, delay_silence = 50, nbr_bip = 3;
 547   1        byte param_find = 0;
 548   1        char * str = 0;
 549   1        
 550   1        // To much args
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 10  

 551   1        if(cmd_packet->cmd_size > 8 || (cmd_packet->cmd_size % 2) != 0)
 552   1        {
 553   2          return 0;
 554   2        }
 555   1        
 556   1        // Analyse each param:value couple
 557   1        for(i = 0 ; i < (cmd_packet->cmd_size/2) ; ++i)
 558   1        {
 559   2          str = (cmd_packet->commands_data + ( ((2*i) + 1) * ARGS_BUFFER_SIZE));
 560   2          
 561   2          // For one couple, identify the param
 562   2          for(j = 0 ; j < 4 ; j++)
 563   2          {
 564   3            if( strcmp(str, params[j]) == 0 )
 565   3            {
 566   4              switch(j)
 567   4              {
 568   5                case 0:
 569   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &frequency_code) == 
             -0)
 570   5                  {
 571   6                    return 0;
 572   6                  }
 573   5                  else
 574   5                  {
 575   6                    // Si pas dans l'intervalle de valeur acceptées
 576   6                    if(frequency_code < 1 || frequency_code > 99)
 577   6                    {
 578   7                      return 0;
 579   7                    }
 580   6                  }
 581   5                  break;
 582   5                
 583   5                case 1:
 584   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &delay_son) == 0)
 585   5                  {
 586   6                    return 0;
 587   6                  } 
 588   5                  else
 589   5                  {
 590   6                    // Si pas dans l'intervalle de valeur acceptées
 591   6                    if(delay_son < 1 || delay_son > 99)
 592   6                    {
 593   7                      return 0;
 594   7                    }
 595   6                  }           
 596   5                  break;
 597   5                
 598   5                case 2:
 599   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &delay_silence) == 0
             -)
 600   5                  {
 601   6                    return 0;
 602   6                  } 
 603   5                  else
 604   5                  {
 605   6                    // Si pas dans l'intervalle de valeur acceptées
 606   6                    if(delay_silence < 1 || delay_silence > 99)
 607   6                    {
 608   7                      return 0;
 609   7                    }
 610   6                  }   
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 11  

 611   5                  break;
 612   5                  
 613   5                case 3:
 614   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &nbr_bip) == 0)
 615   5                  {
 616   6                    return 0;
 617   6                  } 
 618   5                  else
 619   5                  {
 620   6                    // Si pas dans l'intervalle de valeur acceptées
 621   6                    if(nbr_bip < 1 || nbr_bip > 99)
 622   6                    {
 623   7                      return 0;
 624   7                    }
 625   6                  } 
 626   5                  break;
 627   5              }
 628   4              param_find = 1;
 629   4              break;
 630   4            }
 631   3          }
 632   2          
 633   2          if(param_find == 0)
 634   2          {
 635   3            return 0;
 636   3          }else{
 637   3            param_find = 0;
 638   3          }
 639   2          
 640   2        }
 641   1        
 642   1        cmd_packet->commands->Etat_GEN_Son = GEN_oui;
 643   1        cmd_packet->commands->GEN_freq_code = frequency_code;
 644   1        cmd_packet->commands->GEN_son_Duree = delay_son;
 645   1        cmd_packet->commands->GEN_silence_Duree = delay_silence;
 646   1        cmd_packet->commands->GEN_nbr_bip = nbr_bip;
 647   1        
 648   1        return 1;
 649   1        
 650   1      }
 651          
 652          byte photo_cmd(CMD_PACKET* cmd_packet)
 653          {
 654   1        byte i = 1, j = 0;
 655   1        char params[5][3] = {"E", "N", "O", "C", "S"};
 656   1        int duree_photo = 1, nbr_photo = 1, mode = 1;
 657   1        byte param_find = 0;
 658   1        char * str = 0;
 659   1        
 660   1        
 661   1        // To much args
 662   1        if(cmd_packet->cmd_size > 5)
 663   1        {
 664   2          return 0;
 665   2        }
 666   1          
 667   1        
 668   1        // Analyse each param:value couple
 669   1        while(i <= cmd_packet->cmd_size)
 670   1        {
 671   2          str = (cmd_packet->commands_data + ( i * ARGS_BUFFER_SIZE));
 672   2          
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 12  

 673   2          // For one couple, identify the param
 674   2          for(j = 0 ; j < 5 ; j++)
 675   2          {
 676   3            if( strcmp(str, params[j]) == 0 )
 677   3            {
 678   4              switch(j)
 679   4              {
 680   5                case 0:
 681   5                  if(sscanf((cmd_packet->commands_data + ( (i+1) * ARGS_BUFFER_SIZE) ), "%d", &duree_photo) == 0)
 682   5                  {
 683   6                    return 0;
 684   6                  }   
 685   5                  i += 2;
 686   5                  break;
 687   5                
 688   5                case 1:
 689   5                  if(sscanf((cmd_packet->commands_data + ( (i+1) * ARGS_BUFFER_SIZE) ), "%d", &nbr_photo) == 0)
 690   5                  {
 691   6                    return 0;
 692   6                  }
 693   5                  i += 2;
 694   5                  break;
 695   5                case 2:
 696   5                  mode = 1;
 697   5                  i++;
 698   5                  break;
 699   5                case 3:
 700   5                  mode = 2;
 701   5                  i++;
 702   5                  break;
 703   5                case 4:
 704   5                  mode = 3;
 705   5                  i++;
 706   5                  break;
 707   5              }
 708   4              param_find = 1;
 709   4              break;
 710   4            }
 711   3          }
 712   2          
 713   2          if(param_find == 0)
 714   2          {
 715   3            return 0;
 716   3          }else{
 717   3            param_find = 0;
 718   3          }
 719   2          
 720   2        }
 721   1        
 722   1        cmd_packet->commands->Photo_Duree = (byte)duree_photo;
 723   1        cmd_packet->commands->Photo_Nbre = (byte)nbr_photo;
 724   1        ( cmd_packet->commands->Etat_Photo =  (mode == 1) ? Photo_1 : ( (mode == 2) ? Photo_Multiple : Photo_cont
             -inue) );
 725   1        return 1;
 726   1      }
 727          
 728          byte photo_OFF_cmd(CMD_PACKET* cmd_packet)
 729          {
 730   1        // To much args
 731   1        if(cmd_packet->cmd_size != 0)
 732   1        {
 733   2          return 0;
C51 COMPILER V9.55   COMMANDS                                                              05/11/2019 14:48:47 PAGE 13  

 734   2        }
 735   1      
 736   1        cmd_packet->commands->Etat_Photo = Photo_stop;
 737   1      
 738   1        return 1;
 739   1      }
 740          
 741          byte aux_cmd(CMD_PACKET* cmd_packet)
 742          {
 743   1        byte * str = 0;
 744   1        char params[4][3] = {"A", "B", "S", "L"};
 745   1        int ticks_value = 0;
 746   1        
 747   1        str = (cmd_packet->commands_data + ( 1 * ARGS_BUFFER_SIZE));
 748   1        
 749   1        // Command A [Tick] to rotate from [Tick] number of ticks 
 750   1        if( strcmp(str, params[0]) == 0 )
 751   1        {
 752   2          if(sscanf((cmd_packet->commands_data + ( 2 * ARGS_BUFFER_SIZE)), "%d", &ticks_value) == 0)
 753   2          {
 754   3            return 0;
 755   3          }
 756   2          cmd_packet->commands->Etat_Mouvement = Avancer;
 757   2          cmd_packet->commands->Pos_Angle = ticks_value;
 758   2          return 1;
 759   2        }
 760   1        
 761   1        // Command B to get back from last calibration position
 762   1        else if( strcmp(str, params[1]) == 0 )
 763   1        {
 764   2          cmd_packet->commands->Etat_Mouvement = Reculer;
 765   2          return 1;
 766   2        }
 767   1        
 768   1        // Command S to save last tick value and start new one
 769   1        else if( strcmp(str, params[2]) == 0 )
 770   1        {
 771   2          cmd_packet->commands->Etat_Mouvement = Stopper;
 772   2          return 1;
 773   2        }
 774   1        
 775   1        // Command to plot ALL ticks _data
 776   1        else if (strcmp(str, params[3]) == 0)
 777   1        {
 778   2          cmd_packet->commands->Etat_Mouvement = Depl_Coord;
 779   2          return 1;
 780   2        }
 781   1        
 782   1        return 0;
 783   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7516    ----
   CONSTANT SIZE    =     98    ----
   XDATA SIZE       =   ----     220
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
