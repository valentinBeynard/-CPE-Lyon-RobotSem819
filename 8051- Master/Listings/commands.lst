C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COMMANDS
OBJECT MODULE PLACED IN .\Objects\commands.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\commands.c LARGE OPTIMIZE(2,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\commands.lst) TABS(2) OBJECT(.\Objects\commands.obj)

line level    source

   1          #include "commands.h"
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          byte default_process(CMD_PACKET* cmd_packet)
   7          {
   8   1        //printf("Non-implemented command !!");
   9   1        cmd_packet->commands->Etat_Epreuve = (enum Epreuve)1;
  10   1        
  11   1        return 1;
  12   1      }
  13          
  14          /*
  15            Commande de démarage de l'épreuve : D [Numéro Epreuve]
  16            Si aucun paramètre rentré, alors on démarre à l'épreuve 1
  17          */
  18          byte epreuve_cmd(CMD_PACKET* cmd_packet)
  19          {
  20   1        int epreuve_index = 1;
  21   1      
  22   1        // Trop d'argument
  23   1        if(cmd_packet->cmd_size > 1)
  24   1        {
  25   2          return 0;
  26   2        }
  27   1      
  28   1        // Si le paramètre correspondant au numéro d'épreuve est présent
  29   1        if(cmd_packet->cmd_size == 1)
  30   1        {
  31   2          // Si valeur non numérique
  32   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%u", &epreuve_index) != 1)
  33   2          {
  34   3            return 0;
  35   3          }
  36   2      
  37   2          // Si pas dans l'intervalle de valeur acceptées
  38   2          if(epreuve_index < 1 || epreuve_index > 9)
  39   2          {
  40   3            return 0;
  41   3          }
  42   2          
  43   2          cmd_packet->commands->Etat_Epreuve = (enum Epreuve)epreuve_index;
  44   2        }
  45   1        else
  46   1        {
  47   2          cmd_packet->commands->Etat_Epreuve = epreuve1;
  48   2        }
  49   1        return 1;
  50   1      }
  51          
  52          byte epreuve_stop(CMD_PACKET* cmd_packet)
  53          {
  54   1        //printf("Non-implemented command !!");
C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 2   

  55   1        cmd_packet->commands->Etat_Epreuve = Epreuve_non;
  56   1        
  57   1        return 1;
  58   1      }
  59          
  60          
  61          byte safety_break_cmd(CMD_PACKET* cmd_packet)
  62          {
  63   1        // Trop d'argument
  64   1        if(cmd_packet->cmd_size > 0)
  65   1        {
  66   2          return 0;
  67   2        }
  68   1      
  69   1        cmd_packet->commands->Etat_Epreuve = Stop_Urgence;
  70   1        
  71   1        return 1;
  72   1      }
  73          
  74          byte set_default_speed_cmd(CMD_PACKET* cmd_packet)
  75          {
  76   1        int motor_speed = 20;
  77   1        
  78   1        // Seu la commande TV valeur est acceptée
  79   1        if(cmd_packet->cmd_size != 1)
  80   1        {
  81   2          return 0;
  82   2        }
  83   1        
  84   1        // Si valeur non numérique
  85   1        if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) != 1)
  86   1        {
  87   2          return 0;
  88   2        }
  89   1        
  90   1        // Si pas dans l'intervalle de valeur acceptées
  91   1        if(motor_speed < 0 || motor_speed > 100)
  92   1        {
  93   2          return 0;
  94   2        }
  95   1        
  96   1        cmd_packet->commands->Vitesse = motor_speed;
  97   1      
  98   1        return 1;
  99   1      }
 100          
 101          byte move_forward_cmd(CMD_PACKET* cmd_packet)
 102          {
 103   1        int motor_speed = 20;
 104   1        
 105   1        if(cmd_packet->cmd_size > 1)
 106   1        {
 107   2          return 0;
 108   2        }
 109   1          
 110   1        cmd_packet->commands->Etat_Mouvement = Avancer;
 111   1      
 112   1        if(cmd_packet->cmd_size == 1)
 113   1        {
 114   2          // Si valeur non numérique
 115   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 116   2          {
C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 3   

 117   3            return 0;
 118   3          }
 119   2          
 120   2          // Si pas dans l'intervalle de valeur acceptées
 121   2          if(motor_speed < 0 || motor_speed > 100)
 122   2          {
 123   3            return 0;
 124   3          }
 125   2          
 126   2          cmd_packet->commands->Vitesse = motor_speed;
 127   2        }else{
 128   2          if(cmd_packet->commands->Vitesse == 0)
 129   2          {
 130   3            cmd_packet->commands->Vitesse = motor_speed;
 131   3          }
 132   2        }
 133   1        return 1;
 134   1      }
 135          
 136          byte move_backward_cmd(CMD_PACKET* cmd_packet)
 137          {
 138   1        int motor_speed = 20;
 139   1        
 140   1        if(cmd_packet->cmd_size > 1)
 141   1        {
 142   2          return 0;
 143   2        }
 144   1          
 145   1        cmd_packet->commands->Etat_Mouvement = Reculer;
 146   1      
 147   1        if(cmd_packet->cmd_size == 1)
 148   1        {
 149   2          // Si valeur non numérique
 150   2          if(sscanf((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "%d", &motor_speed) == 0)
 151   2          {
 152   3            return 0;
 153   3          }
 154   2          
 155   2          // Si pas dans l'intervalle de valeur acceptées
 156   2          if(motor_speed < 0 || motor_speed > 100)
 157   2          {
 158   3            return 0;
 159   3          }
 160   2          
 161   2          cmd_packet->commands->Vitesse = motor_speed;
 162   2        }else{
 163   2          if(cmd_packet->commands->Vitesse == 0)
 164   2          {
 165   3            cmd_packet->commands->Vitesse = motor_speed;
 166   3          }
 167   2        }
 168   1        return 1;
 169   1      }
 170          
 171          byte move_stop_cmd(CMD_PACKET* cmd_packet)
 172          { 
 173   1        if(cmd_packet->cmd_size != 0)
 174   1        {
 175   2          return 0;
 176   2        }
 177   1        cmd_packet->commands->Etat_Mouvement = Stopper;
 178   1        return 1;
C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 4   

 179   1      }
 180          
 181          byte rigth_rotation_cmd(CMD_PACKET* cmd_packet)
 182          {
 183   1        if(cmd_packet->cmd_size != 0)
 184   1        {
 185   2          return 0;
 186   2        }
 187   1        
 188   1        cmd_packet->commands->Etat_Mouvement = Rot_90D;
 189   1        return 1;
 190   1      }
 191          
 192          byte left_rotation_cmd(CMD_PACKET* cmd_packet)
 193          {
 194   1        if(cmd_packet->cmd_size != 0)
 195   1        {
 196   2          return 0;
 197   2        }
 198   1        
 199   1        cmd_packet->commands->Etat_Mouvement = Rot_90G;
 200   1        return 1;
 201   1      }
 202          
 203          byte complete_rotation_cmd(CMD_PACKET* cmd_packet)
 204          {
 205   1        if(cmd_packet->cmd_size > 1)
 206   1        {
 207   2          return 0;
 208   2        }
 209   1      
 210   1        if(cmd_packet->cmd_size == 1)
 211   1        {
 212   2          
 213   2          if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "D") == 0 
 214   2            || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "G") == 0)
 215   2          {
 216   3            switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 217   3            {
 218   4              case 'D':
 219   4                cmd_packet->commands->Etat_Mouvement = Rot_180D;
 220   4                break;
 221   4              default :
 222   4                cmd_packet->commands->Etat_Mouvement = Rot_180G;
 223   4                break;
 224   4            }
 225   3          }else{
 226   3            return 0;
 227   3          }
 228   2      
 229   2        }else{
 230   2          cmd_packet->commands->Etat_Mouvement = Rot_180D;
 231   2        }
 232   1        return 1;
 233   1      }
 234          
 235          byte angle_rotation_cmd(CMD_PACKET* cmd_packet)
 236          {
 237   1        unsigned int angle = 0;
 238   1        
 239   1        if(cmd_packet->cmd_size != 2)
 240   1        {
C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 5   

 241   2          return 0;
 242   2        }
 243   1        
 244   1        if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "D") == 0 
 245   1            || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "G") == 0)
 246   1        {
 247   2          switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 248   2          {
 249   3            case 'D':
 250   3              cmd_packet->commands->Etat_Mouvement = Rot_AngD;
 251   3              break;
 252   3            default :
 253   3              cmd_packet->commands->Etat_Mouvement = Rot_AngG;
 254   3              break;
 255   3          }
 256   2          
 257   2          if(sscanf((cmd_packet->commands_data + (2 * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 258   2          {
 259   3            return 0;
 260   3          }
 261   2          
 262   2          cmd_packet->commands->Angle = (int)(angle);
 263   2        }else{
 264   2          return 0;
 265   2        }
 266   1        return 1;
 267   1      }
 268          
 269          /*
 270            Move to (X,Y,alpha) coordinate
 271          
 272            Ex : "G X:10 Y:15 A:45"
 273          
 274            Function exclude from Data Overlaying in "linker_directives" : OVERLAY( * ! move_to_cmd )
 275          
 276          */
 277          byte move_to_cmd(CMD_PACKET* cmd_packet)
 278          {
 279   1        byte i = 0, j = 0;
 280   1        char params[3][5] = {"X", "Y", "A"};
 281   1        int angle = 0, x = 0, y = 0;
 282   1        byte param_find = 0;
 283   1        char * str = 0;
 284   1        
 285   1        
 286   1        // Not enougthl args
 287   1        if(cmd_packet->cmd_size != 6)
 288   1        {
 289   2          return 0;
 290   2        }
 291   1        
 292   1        // Analyse each param:value couple
 293   1        for(i = 0 ; i < 3 ; ++i)
 294   1        {
 295   2          str = (cmd_packet->commands_data + ( ((2*i) + 1) * ARGS_BUFFER_SIZE));
 296   2          
 297   2          // For one couple, identify the param
 298   2          for(j = 0 ; j < 3 ; j++)
 299   2          {
 300   3            if( strcmp(str, params[j]) == 0 )
 301   3            {
 302   4              switch(j)
C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 6   

 303   4              {
 304   5                case 0:
 305   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &x) == 0)
 306   5                  {
 307   6                    return 0;
 308   6                  }         
 309   5                  break;
 310   5                
 311   5                case 1:
 312   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &y) == 0)
 313   5                  {
 314   6                    return 0;
 315   6                  }   
 316   5                  break;
 317   5                
 318   5                case 2:
 319   5                  if(sscanf((cmd_packet->commands_data + ((2 + i * 2) * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 320   5                  {
 321   6                    return 0;
 322   6                  } 
 323   5                  break;
 324   5                
 325   5              }
 326   4              param_find = 1;
 327   4              break;
 328   4            }
 329   3          }
 330   2          
 331   2          if(param_find == 0)
 332   2          {
 333   3            return 0;
 334   3          }else{
 335   3            param_find = 0;
 336   3          }
 337   2          
 338   2        }
 339   1        
 340   1        cmd_packet->commands->Angle = angle;
 341   1        cmd_packet->commands->Coord_X = (byte)x;
 342   1        cmd_packet->commands->Coord_Y = (byte)y;
 343   1        cmd_packet->commands->Etat_Mouvement = Depl_Coord;
 344   1        return 1;
 345   1      }
 346          
 347          byte detecte_obstacle(CMD_PACKET* cmd_packet)
 348          {
 349   1        if(cmd_packet->cmd_size != 0)
 350   1        {
 351   2          return 0;
 352   2        }
 353   1        
 354   1        cmd_packet->commands->Etat_DCT_Obst = oui_180;
 355   1        return 1;
 356   1      }
 357          
 358          byte servo_move_cmd(CMD_PACKET* cmd_packet)
 359          {
 360   1        int angle = 45;
 361   1        
 362   1        if(cmd_packet->cmd_size > 3)
 363   1        {
 364   2          return 0;
C51 COMPILER V9.55   COMMANDS                                                              04/16/2019 17:35:36 PAGE 7   

 365   2        }
 366   1        
 367   1        if(strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "H") == 0 
 368   1          || strcmp((cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE)), "V") == 0)
 369   1        {
 370   2          switch( (*(cmd_packet->commands_data + (1 * ARGS_BUFFER_SIZE))) )
 371   2          {
 372   3            case 'V':
 373   3              cmd_packet->commands->Etat_Servo = Servo_V;
 374   3              break;
 375   3            default :
 376   3              cmd_packet->commands->Etat_Servo = Servo_H;
 377   3              break;
 378   3          }
 379   2          
 380   2        }
 381   1        
 382   1        if(strcmp((cmd_packet->commands_data + (2 * ARGS_BUFFER_SIZE)), "A") == 0 )
 383   1        {
 384   2          if(sscanf((cmd_packet->commands_data + (3 * ARGS_BUFFER_SIZE)), "%d", &angle) == 0)
 385   2          {
 386   3            return 0;
 387   3          }
 388   2        
 389   2          cmd_packet->commands->Servo_Angle = (char)(angle);
 390   2        }
 391   1        
 392   1        return 1;
 393   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3527    ----
   CONSTANT SIZE    =     31    ----
   XDATA SIZE       =   ----      84
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
